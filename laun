srcs/builtins/cd.c:	if ((var = search_db(shell->env, "HOME")) == NULL)
srcs/builtins/cd.c:	if ((var = search_db(shell->env, "OLDPWD")) == NULL)
srcs/builtins/fc/fc.c:	if ((saved = shell->history) == NULL)
srcs/builtins/fc/fc.c:	cmd = ft_strsplit(shell->buff, SPACE);
srcs/builtins/fc/fc_edit.c:	ft_strcpy(shell->buff, ed);
srcs/builtins/fc/fc_specifier.c:	ft_bzero(shell->buff, ft_strlen(shell->buff));
srcs/builtins/fc/fc_specifier.c:	shell->buff = ft_strdup(w->content);
srcs/builtins/fc/fc_specifier.c:	get_tokens(shell, shell->buff);
srcs/builtins/fc/fc_specifier.c:	ft_printf("%s\n", shell->buff);
srcs/builtins/fc/fc_specifier.c:	exec_process(shell, shell->env);
srcs/builtins/fg.c:		job = get_job_by_id(shell->launched_jobs, ft_atoi(process->av[1] + 1));
srcs/builtins/fg.c:		job = get_job_by_name(shell->launched_jobs, process->av[1]);
srcs/builtins/fg.c:		job = get_last_job(shell->launched_jobs);
srcs/builtins/set.c:	ptr = shell->env;
srcs/builtins/set.c:	shell->db.key = ft_itoa(count);
srcs/builtins/set.c:	shell->db.value = ft_strdup(arg);
srcs/builtins/set.c:	shell->db.type = SPECIAL_VAR;
srcs/builtins/set.c:	if (!shell->db.key || !shell->db.value || ft_lstappend(&shell->pos_vars
srcs/builtins/set.c:				, ft_lstnew(&shell->db, sizeof(t_db))) == NULL)
srcs/builtins/set.c:		ft_strdel(&(shell->db.key));
srcs/builtins/set.c:		ft_strdel(&(shell->db.value));
srcs/builtins/set.c:	free_env(shell->pos_vars);
srcs/builtins/set.c:	shell->pos_vars = NULL;
srcs/command_line/auto_completion/ac_tools.c:	env = input->shell->env;
srcs/command_line/auto_completion/ac_tools.c:	env = shell->env;
srcs/command_line/term_config.c:	if (tcgetattr(STDIN_FILENO, &(shell->old_t)) == FAILURE)
srcs/command_line/term_config.c:	shell->new_t = shell->old_t;
srcs/command_line/term_config.c:	shell->new_t.c_lflag &= ~(ICANON | ECHO);
srcs/command_line/term_config.c:	shell->new_t.c_cc[VMIN] = 1;
srcs/command_line/term_config.c:	shell->new_t.c_cc[VTIME] = 0;
srcs/command_line/term_config.c:	if (tcsetattr(STDIN_FILENO, TCSANOW, &(shell->new_t)) == FAILURE)
srcs/command_line/term_config.c:	tcsetattr(STDOUT_FILENO, TCSANOW, &(shell->old_t));
srcs/core/free_handler.c://	ft_freejoblist(&shell->job_list);
srcs/core/free_handler.c:	shell->job_list = NULL;
srcs/core/init_shell.c:	shell->build = (struct s_build){BUILDR, BUILDV, BUILDP + 1, DATE};
srcs/core/init_shell.c:	shell->hash.size = HASH_SIZE;
srcs/core/init_shell.c:	shell->terminal = STDIN_FILENO;
srcs/core/init_shell.c:	if ((shell->is_interactive = isatty(shell->terminal)))
srcs/core/init_shell.c:		while (tcgetpgrp(shell->terminal) != (shell->pgid = getpgrp()))
srcs/core/init_shell.c:			kill(- shell->pgid, SIGTTIN);
srcs/core/init_shell.c:		shell->pgid = getpid();
srcs/core/init_shell.c:		if (setpgid(shell->pgid, shell->pgid) < 0)
srcs/core/init_shell.c:		if (tcsetpgrp(shell->terminal, shell->pgid) != SUCCESS)
srcs/core/init_shell.c:		if (tcgetattr(shell->terminal, &(shell->old_t)) != SUCCESS)
srcs/core/load_noi_mode.c:	lexer_parser_analyzer(shell, shell->cmd_line.buffer);
srcs/core/load_noi_mode.c:	free_prompt(shell, shell->cmd_line.buffer);
srcs/core/load_noi_mode.c:	ft_strdel(&(shell->cmd_line.buffer));
srcs/core/load_prompt.c:	term = &(shell->cmd_line);
srcs/core/load_prompt.c:		// ft_freejoblist(&shell->job_list);
srcs/core/output.c:		shell->build.release, shell->build.version, shell->build.patch,
srcs/core/output.c:	if ((shell->opt = get_options(ac, av, "hv")) & OPT_ERROR)
srcs/core/output.c:		print_usage("42sh", shell->opt % 128, "42sh [-hv]");
srcs/core/output.c:	if (shell->opt & OPT_HELP)
srcs/core/output.c:	if (shell->opt & OPT_VERS)
srcs/core/output.c:			shell->build.release, shell->build.version,
srcs/core/output.c:			shell->build.patch, shell->build.date);
srcs/db/db_tools.c:	db = search_db(shell->env, key);
srcs/db/db_tools.c:		ft_lstappend(&(shell->env),
srcs/db/db_tools.c:			ft_lstnew(fetch_db(&(shell->db), key, var_type), sizeof(t_db)));
srcs/db/db_tools.c:		db = search_db(shell->env, key);
srcs/db/db_tools.c:	prev = shell->env;
srcs/db/db_tools.c:	env = shell->env;
srcs/db/db_tools.c:		**	linking the previous link (or shell->env pointer) to the next link
srcs/db/db_tools.c:			shell->env = env->next;
srcs/db/get_opt.c:**	[BETA] The get_opt fonction parses char **av in main. Fill shell->opt and
srcs/db/get_opt.c:		shell->opt |= OPT_VERS;
srcs/db/get_opt.c:		shell->opt |= OPT_HELP;
srcs/db/process_vars.c:	ptr = shell->jobs;
srcs/db/set_env.c:		ft_lstappend(&shell->env,
srcs/db/set_env.c:			ft_lstnew(fetch_db(&shell->db, environ[i], ENV_VAR), sizeof(t_db)));
srcs/db/set_updates.c:	if (search_db(shell->env, "TERM") == NULL)
srcs/db/set_updates.c:		if (ft_lstappend(&(shell->env), ft_lstnew(
srcs/db/set_updates.c:				fetch_db(&(shell->db), "TERM=dumb", INTERNAL_VAR)
srcs/db/set_updates.c:		if (!(value = ft_itoa(shell->cmd_line.ws_li))
srcs/db/set_updates.c:		if (!(value = ft_itoa(shell->cmd_line.ws_col))
srcs/db/special_vars.c:		value = ft_itoa(ft_lstlen(shell->pos_vars));
srcs/db/special_vars.c:		value = ft_itoa(shell->status);
srcs/db/version.c:	ft_itoabuf(shell->build.release, version);
srcs/db/version.c:	ft_itoabuf(shell->build.version, version);
srcs/db/version.c:	ft_itoabuf(shell->build.patch, version);
srcs/dev.c:	env = shell->env;
srcs/dev.c:	if (shell->job_list)
srcs/dev.c:		tmp = shell->job_list;
srcs/exec/dispatcher.c:	if (!shell->is_interactive)
srcs/exec/dispatcher.c:	else if (cond == P_ANDIF && shell->status == 0)
srcs/exec/dispatcher.c:	else if (cond == P_ORIF && shell->status != 0)
srcs/exec/exec_process.c:	if (shell->is_interactive)
srcs/exec/exec_process.c:		&& outfile == STDOUT_FILENO && tcsetpgrp(shell->terminal, process->pgid) != SUCCESS)
srcs/exec/exec_process.c:			if (tcsetpgrp(shell->terminal, shell->pgid) != SUCCESS)
srcs/exec/get_bin.c:	if (!(db = search_db(shell->env, "PATH")))
srcs/exec/hash_map/add_hash_map.c:	if (shell->hash.map == NULL
srcs/exec/hash_map/add_hash_map.c:		&& !(shell->hash.map = ft_memalloc(sizeof(t_lst*) * shell->hash.size)))
srcs/exec/hash_map/add_hash_map.c:	load_factor = shell->hash.lenght / shell->hash.size;
srcs/exec/hash_map/add_hash_map.c:	shell->hash.value = get_hash(process->av[0], shell->hash.size);
srcs/exec/hash_map/add_hash_map.c:	shell->hash.lenght++;
srcs/exec/hash_map/add_hash_map.c:	ft_lstappend(&shell->hash.map[shell->hash.value],
srcs/exec/hash_map/add_hash_map.c:		ft_lstnew(fetch_hash_db(&shell->db, process->av[0],
srcs/exec/hash_map/locate_hash.c:	if (shell->hash.map == NULL)
srcs/exec/hash_map/locate_hash.c:	map = shell->hash.map;
srcs/exec/hash_map/locate_hash.c:	//shell->hash.value = get_hash(process->av[0], shell->hash.size);
srcs/exec/hash_map/locate_hash.c:	if (map[shell->hash.value] == NULL)
srcs/exec/hash_map/locate_hash.c:	sub_map = map[shell->hash.value];
srcs/exec/hash_map/resize_hash_map.c:	while (i < shell->hash.size)
srcs/exec/hash_map/resize_hash_map.c:			shell->hash.lenght++;
srcs/exec/hash_map/resize_hash_map.c:			shell->hash.value = get_hash(((t_db*)(sub_map->content))->key,
srcs/exec/hash_map/resize_hash_map.c:									(shell->hash.size * 2));
srcs/exec/hash_map/resize_hash_map.c:			ft_lstappend(&new_map[shell->hash.value],
srcs/exec/hash_map/resize_hash_map.c:				ft_lstnew(fetch_hash_db(&shell->db,
srcs/exec/hash_map/resize_hash_map.c:	map = shell->hash.map;
srcs/exec/hash_map/resize_hash_map.c:	shell->hash.lenght = 0;
srcs/exec/hash_map/resize_hash_map.c:	if (!(new_map = ft_memalloc(sizeof(t_lst*) * (shell->hash.size * 2))))
srcs/exec/hash_map/resize_hash_map.c:	free_hash_map(&(shell->hash));
srcs/exec/hash_map/resize_hash_map.c:	shell->hash.map = new_map;
srcs/exec/hash_map/resize_hash_map.c:	shell->hash.size *= 2;
srcs/exec/redirections/exec_redirs.c:			((t_redir*)redirs->content)->dup_fd = shell->heredoc++;
srcs/exec/set_envp.c:	env = shell->env;
srcs/exec/set_envp.c:	env = shell->env;
srcs/exec/status_handler.c:		shell->status = status + 128;
srcs/exec/status_handler.c:		shell->status /= 256;
srcs/exec/status_handler.c:		shell->status &= 0xFF;
srcs/exec/task_master.c:	job = shell->job_list;
srcs/expansions/cmd_subs_expansion.c:// 		if (waitpid(child, &shell->status, WCONTINUED) != child)
srcs/expansions/cmd_subs_expansion.c:// 	// tmp_lst = shell->job_list;
srcs/expansions/cmd_subs_expansion.c:// 	// shell->job_list = lst_job;
srcs/expansions/expansion.c:	if (!data || !shell->env)
srcs/expansions/param_expansion.c:	if ((db_tmp = search_db(shell->env, tmp)))
srcs/expansions/tilde_expansion.c:	if ((db_tmp = search_db(shell->env, path[i])))
srcs/jobcontrol/foreground.c:	if (tcsetpgrp(shell->terminal, job->pgid) != SUCCESS)
srcs/jobcontrol/foreground.c:		if (tcsetattr(shell->terminal, TCSADRAIN, &(job->tmodes)) != SUCCESS)
srcs/jobcontrol/foreground.c:	if (tcsetpgrp(shell->terminal, shell->pgid) != SUCCESS)
srcs/jobcontrol/foreground.c:	if (tcgetattr(shell->terminal, &job->tmodes) != SUCCESS)
srcs/jobcontrol/foreground.c:	if (tcsetattr(shell->terminal, TCSADRAIN, &shell->new_t) != SUCCESS)
srcs/jobcontrol/launch_job.c:	if (!shell->is_interactive)
srcs/jobcontrol/launch_job.c:		if (shell->is_interactive)
srcs/jobcontrol/launch_process.c:		shell->status = process->status;
srcs/jobcontrol/launch_process.c:	if (shell->is_interactive)
srcs/jobcontrol/notifications.c:		process = find_process(shell->launched_jobs, pid);
srcs/jobcontrol/notifications.c:				shell->status = process->status;
srcs/jobcontrol/notifications.c:	ptr = shell->job_list;
srcs/jobcontrol/notifications.c:	if (shell->job_list != job)
srcs/jobcontrol/notifications.c:		shell->job_list = job->next;
srcs/jobcontrol/notifications.c:	job = shell->launched_jobs;
srcs/jobcontrol/notifications.c:			ft_lstappend(&(shell->launched_jobs), job);
srcs/lexer_parser_analyzer/analyzer/analyze.c:	shell->job_list = anal->job_list;
srcs/lexer_parser_analyzer/lexer_parser_analyzer.c:	shell->job_list = NULL;
srcs/lexer_parser_analyzer/lexer_parser_analyzer.c:		//ft_printjoblst(shell->job_list);
srcs/misc/quit_shell.c:	reset_config(shell, &(shell->cmd_line));
srcs/signals/init_signals.c:	if (signum == SIGHUP && shell->running_process)
srcs/signals/init_signals.c:	if (get_size(&(shell->cmd_line)) != SUCCESS || update_termsize(shell))
srcs/signals/sigint.c:	ptr = shell->running_process->next;
srcs/signals/sigint.c:	kill(((t_process*)shell->running_process->content)->pid, signum);
srcs/signals/sigint.c:	shell->running_process = NULL;
srcs/signals/sigint.c:	if (shell->cmd_line.status == CMD_PROMPT)
srcs/signals/sigint.c:		while (shell->cmd_line.x_index < shell->cmd_line.width)
srcs/signals/sigint.c:			move_right(shell->cmd_line.buffer, &(shell->cmd_line));
srcs/signals/sigint.c:		ft_bzero(shell->cmd_line.buffer, BUFF_SIZE);
srcs/signals/sigint.c:		display_prompt(&(shell->cmd_line));
srcs/signals/sigint.c:	else if (shell->cmd_line.status == CMD_SUBPROMPT)
srcs/signals/sigint.c:		ft_bzero(shell->cmd_line.tmp_buff, ft_strlen(shell->cmd_line.tmp_buff));
srcs/signals/sigint.c:		ft_strdel(&(shell->cmd_line.tmp_buff));
srcs/signals/sigint.c:		ft_bzero(shell->cmd_line.buffer, BUFF_SIZE);
srcs/signals/sigint.c:		shell->cmd_line.status = CMD_PROMPT;
srcs/signals/sigint.c:		display_prompt(&(shell->cmd_line));
srcs/signals/sigint.c:	if (shell->running_process != NULL)
