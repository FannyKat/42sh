#include "sh42.h"

t_analyzer *expansion_analyze(t_analyzer *analyzer, t_core *shell)
{
	char *tmp;

	tmp = NULL;
	analyzer->job.command = fill_cmd_job(analyzer, 1);
	ft_dprintf(getlefdpour_debug_ailleurs("/dev/ttys002"), "EXPANSION state %u || token id %u || token data %s\n", analyzer->state, ((t_token*)analyzer->lexer->content)->id ,((t_token*)analyzer->lexer->content)->data);
	if (((t_token*)analyzer->lexer->content)->id == P_DBPARENT || ((t_token*)analyzer->lexer->content)->id == P_HOOK)
	{
		if ((tmp = arithmetique_expansion(((t_token*)analyzer->lexer->content), shell)))
		{
			free(((t_token*)analyzer->lexer->content)->data);
			((t_token*)analyzer->lexer->content)->data = ft_strdup(tmp);
		}
		analyzer->state = A_WORD;
		cmd_analyze(analyzer, shell);
		return (analyzer);
	}
	if (((t_token*)analyzer->lexer->content)->id == P_PARENT)
	{
		if ((tmp = cmd_substitution_expansion(((t_token*)analyzer->lexer->content), shell)))
		{
			free(((t_token*)analyzer->lexer->content)->data);
			((t_token*)analyzer->lexer->content)->data = ft_strdup(tmp);
		}
		analyzer->state = A_WORD;
		return (cmd_analyze(analyzer, shell));
		// return (analyzer);
	}
	else if (((t_token*)analyzer->lexer->content)->id == P_BRACKET || ((t_token*)analyzer->lexer->content)->id == P_DOLLAR)
	{
		if ((tmp = param_expansion(((t_token*)analyzer->lexer->content), shell)))
		{
			free(((t_token*)analyzer->lexer->content)->data);
			((t_token*)analyzer->lexer->content)->data = ft_strdup(tmp);	
		}
		analyzer->state = A_WORD;
		cmd_analyze(analyzer, shell);
		return (analyzer);
	}
	if (((t_token*)analyzer->lexer->content)->id == P_TILDE)
	{
		if ((tmp = tilde_expansion(((t_token*)analyzer->lexer->content)->data, shell)))
		{
			free(((t_token*)analyzer->lexer->content)->data);
			((t_token*)analyzer->lexer->content)->data = ft_strdup(tmp);
		}
		analyzer->state = A_WORD;
		return (analyzer = cmd_analyze(analyzer, shell));
	}
	return (analyzer);
}






____________________________________________________________




//USELESSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS
// char 		*exp_bracket(t_token *tok, char *expansion, t_core *shell);
// {
// 	char *str;
// 	int index;

// 	index = 0;
// 	str = NULL;

// 	if (!ft_strncmp(&lexer->buff[lexer->buf_pos], "${", len))
// 	{
// 		index = lexer->buf_pos;
// 		while (&lexer->buff[index])
// 		{
// 			if (lexer->buff[index] == '}')
// 			{
// 				break; // CECI EST UN BUG
// 			}
// 			else
// 				index++;
// 			if (!lexer->buff[index + 1])
// 			{
// 				ft_dprintf(2, "braceparam>\n" );
// 				// lexer->buf_pos = index;
// 				// return (lexer_token);
// 				break;
// 				// subprompt("braceparam>");
// 			}
// 		}
// 		index++;
// 		if (!(str = ft_strsub(lexer->buff, lexer->buf_pos, index - lexer->buf_pos)))
// 			return (NULL);
// 		if (!(ft_lstappend(&lexer_token, ft_lstnew(fetch_lexer_token(&lexer->token ,id, str), sizeof(t_token)))))
// 			return (NULL);
// 		free(str);
// 		lexer->ntok++;
// 		lexer->buf_pos = index;
// 	}
// 	return (lexer_token);
// }

// char 		*exp_tilde(t_token *tok, char *expansion, t_core *shell);
// {
// 	char *str;

// 	str = NULL;
// 	if ( == '~')
// 	{
// 		if (!(str = ft_strsub(lexer->buff, lexer->buf_pos, len)))
// 			return (NULL);
// 		if (!(ft_lstappend(&lexer_token, ft_lstnew(fetch_lexer_token(&lexer->token ,id, str), sizeof(t_token)))))
// 			return (NULL);
// 		free(str);
// 		lexer->ntok++;
// 		lexer->buf_pos += len;
// 	}
// 	return (lexer_token);
// }


// char 		*exp_dollar(t_token *tok, char *expansion, t_core *shell);
// {
// 	char *str;
// 	int index;

// 	index = lexer->buf_pos + len;
// 	str = NULL;
// 	(void)len;
// 	if (lexer->buff[lexer->buf_pos] == '$')
// 	{
// 		while (lexer->buff[index])
// 		{
// 			if (lexer->buff[index] == '_' || ft_isdigit(lexer->buff[index]) || ft_isalpha(lexer->buff[index]))
// 				index++;
// 			else
// 			{
// 				// lexer->buf_pos++;
// 				// return (lexer_token);
// 				break;
// 			}
// 		}
// 		if (!(str = ft_strsub(lexer->buff, lexer->buf_pos, index - lexer->buf_pos)))
// 			return (NULL);
// 		if (!(ft_lstappend(&lexer_token, ft_lstnew(fetch_lexer_token(&lexer->token ,id, str), sizeof(t_token)))))
// 			return (NULL);
// 		free(str);
// 		lexer->ntok++;
// 		lexer->buf_pos = index;
// 	}
// 	return (lexer_token);
// }

// 	if (analyzer->state == A_ASSIGN)
// 	{
// 		analyzer->db.value = ft_strdup(((t_token*)analyzer->lexer->content)->data);
// 		ass_analyze(analyzer, shell);
// 		analyzer->state = A_START;
// 	}
// 	if (((t_token*)analyzer->lexer->next->content)->id == P_ASSIGN && analyzer->state != A_WORD)
// 	{
// 		analyzer->db.key = ft_strjoinf(tmp, "=", 1);
// 		analyzer->process.type = ((t_token*)analyzer->lexer->content)->id;
// 		analyzer->state = A_ASSIGN;
// 		get_token(analyzer);
// 	}

// static char	*create_expansions_token(char *expansions, t_token *exp_token, t_core *shell)
// {	
// 	int i;
// 	t_expansion expansions[] = {
// 								{exp_tilde_exp, P_TILDE, 1},
// 								{exp_dbparen_exp, P_DBPARENT, 3},
// 								{exp_paren_exp, P_PARENT, 2},
// 								{exp_bracket_exp, P_BRACKET, 2},
// 								{exp_hook_exp, P_HOOK, 2},
// 								{exp_dollar_exp, P_DOLLAR, 1},
// 								};

// 	i = 0;
// 	while (i < NB_OF_EXP)
// 	{
// 		if (id == expansions[i].id)
// 		{

// 			if ((lexer_token = 	// while (i < NB_OF_EXP)
	// {
		// if (!ft_strncmp(expansion, quotes[i].data, quotes[i].data_len))
		// {
		// 	return(get_expansion_commeunguedin(expansion, exp[quotes[i].id].func(quotes, expansion, shell)));
		// }
		// i++;
	// }))
// 				return (lexer_token);
// 		}
// 		i++;
// 	}
// 	return (lexer_token);
// }

// char *get_expansion_commeunguedin(char *expansion, func(t_token*, char*, t_core *))
// {
// 	printf("totototo\n");
// }

// static t_token    quotes[] =
	// 					{
	// 						{P_TILDE, "~", 1},
	// 						{P_DBPARENT, "$((", 3},
	// 						{P_PARENT, "$(", 2},
	// 						{P_BRACKET, "${", 2},
	// 						{P_HOOK, "$[", 2},
	// 						{P_DOLLAR, "$", 1},
	// 						{P_EXP_INTERRUPT, NULL, 0}
	// 					};
	// while (new_exp[i])
	// {		
	// 	if (new_exp[i] == '~')
	// 		return (exp_tilde(&(quotes[0]), new_exp, shell));
	// 	if (new_exp[i] == '$')
	// 		return (exp_tilde(&(quotes[0]), new_exp, shell));
	// 		// return (exp_dollar(&(quotes[5]), new_exp, shell));
	// 	else
	// 	{
	// 		index++;
	// 		break;
	// 	}
	// 	i++;
	// }
	// return (expansion->result);
	// (void)shell;
