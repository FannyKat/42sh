shared_libft/srcs/ft_atoi.c:	if (s[i] == '+' || s[i] == '-')
shared_libft/srcs/ft_atoi.c:		sign *= (s[i++] == '-' ? -1 : 1);
shared_libft/srcs/ft_atoi.c:		nb = (nb * 10) + (s[i++] - '0');
shared_libft/srcs/ft_atol.c:/*   Created: 2020/02/17 14:09:27 by mpivet-p          #+#    #+#             */
shared_libft/srcs/ft_atol.c:	if (s[i] != '-' && s[i] != '+' && !(s[i] >= '0' && s[i] <= '9'))
shared_libft/srcs/ft_atol.c:		return (-1);
shared_libft/srcs/ft_atol.c:	if (s[i] == '+' || s[i] == '-')
shared_libft/srcs/ft_atol.c:		sign *= (s[i++] == '-') ? -1 : 1;
shared_libft/srcs/ft_atol.c:		*result = (*result * 10) + ((s[i++] - '0') * sign);
shared_libft/srcs/ft_atol.c:		if ((sign == -1 && save < *result) || (sign == 1 && save > *result))
shared_libft/srcs/ft_atol.c:			return (-1);
shared_libft/srcs/ft_atol.c:	return ((s[i] != 0) ? -1 : 0);
shared_libft/srcs/ft_get_options.c:/*   Created: 2019/09/28 23:48:13 by mpivet-p          #+#    #+#             */
shared_libft/srcs/ft_get_options.c:**	+--------+---------+---------+------------------------------------------+
shared_libft/srcs/ft_get_options.c:**	| a - z  |  A - Z  |  0 - 9  |             unallowed option             |
shared_libft/srcs/ft_get_options.c:**	+--------+---------+---------+------------------------------------------+
shared_libft/srcs/ft_get_options.c:**	| 0 - 25 | 26 - 51 | 52 - 61 | 63. return % 128 to get unallowed option |
shared_libft/srcs/ft_get_options.c:**	+--------+---------+---------+------------------------------------------+
shared_libft/srcs/ft_get_options.c:**	"-c" option = [00000000 00000100]
shared_libft/srcs/ft_get_options.c:	while (++j < (size_t)argc && argv[j][0] == '-')
shared_libft/srcs/ft_get_options.c:			if (argv[j][0] != '-' || (argv[j][0] == '-'
shared_libft/srcs/ft_get_options.c:						&& argv[j][1] == '-' && argv[j][2] == 0))
shared_libft/srcs/ft_get_options.c:				ret = ret | (1ULL << (argv[j][i] - 'a'));
shared_libft/srcs/ft_get_options.c:				ret = ret | (1ULL << ((argv[j][i] - 'A') + 26));
shared_libft/srcs/ft_get_options.c:				ret = ret | (1ULL << ((argv[j][i] - '0') + 52));
shared_libft/srcs/ft_getnextline.c:/*   Updated: 2020/03/08 13:56:05 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_getnextline.c:	if (fd == -1 || FD_MAXSET > 4864 || BUFF_SZ < 1
shared_libft/srcs/ft_getnextline.c:		return (-1);
shared_libft/srcs/ft_is_number.c:/*   Created: 2019/12/01 09:23:40 by mpivet-p          #+#    #+#             */
shared_libft/srcs/ft_is_number.c:			return (-1);
shared_libft/srcs/ft_isalnum.c:/*   Created: 2019/09/30 04:19:04 by mpivet-p          #+#    #+#             */
shared_libft/srcs/ft_isnum.c:	if (*str == '-')
shared_libft/srcs/ft_itoa.c:		do_conv(buffer, n / 10, --i);
shared_libft/srcs/ft_itoa.c:		s[0] = '-';
shared_libft/srcs/ft_itoa.c:		do_conv(s + 1, -(long)n, len);
shared_libft/srcs/ft_itoa_base.c:/*   Updated: 2020/03/08 13:29:26 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_itoa_base.c:	str[i--] = '\0';
shared_libft/srcs/ft_itoa_base.c:		i--;
shared_libft/srcs/ft_itoa_base.c:		str[0] = '-';
shared_libft/srcs/ft_itoa_base.c:		str[z] = hex[converted_nbr[i--]];
shared_libft/srcs/ft_itoa_base.c:	n = (nbr > 0 ? (u_int64_t)nbr : -(u_int64_t)nbr);
shared_libft/srcs/ft_itoa_base_custom.c:/*   Updated: 2020/03/08 13:29:50 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_itoa_base_custom.c:	i--;
shared_libft/srcs/ft_itoa_base_custom.c:		str[n++] = hex[converted_nbr[i--]];
shared_libft/srcs/ft_itoabuf.c:/*   Created: 2019/09/18 17:21:03 by mpivet-p          #+#    #+#             */
shared_libft/srcs/ft_itoabuf.c:		return (-1);
shared_libft/srcs/ft_lstappend.c:		while (node->next)
shared_libft/srcs/ft_lstappend.c:			node = node->next;
shared_libft/srcs/ft_lstappend.c:		node->next = new;
shared_libft/srcs/ft_lstappend.c:		new->prev = node;
shared_libft/srcs/ft_lstlen.c:	while (node->next)
shared_libft/srcs/ft_lstlen.c:		node = node->next;
shared_libft/srcs/ft_lstnew.c:/*   Updated: 2020/03/08 13:55:49 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_lstnew.c:		node->content = NULL;
shared_libft/srcs/ft_lstnew.c:		node->content_size = 0;
shared_libft/srcs/ft_lstnew.c:		node->next = NULL;
shared_libft/srcs/ft_lstnew.c:		node->prev = NULL;
shared_libft/srcs/ft_lstnew.c:	node->content = elem;
shared_libft/srcs/ft_lstnew.c:	node->content_size = content_size;
shared_libft/srcs/ft_lstnew.c:	node->next = NULL;
shared_libft/srcs/ft_lstnew.c:	node->prev = NULL;
shared_libft/srcs/ft_memalloc.c:/*   Updated: 2020/03/08 13:56:27 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_memcpy.c:	while (n--)
shared_libft/srcs/ft_memdel.c:/*   By: mpivet-p <marvin@42.fr>                    +#+  +:+       +#+        */
shared_libft/srcs/ft_memdel.c:/*   Created: 2018/11/10 20:37:01 by mpivet-p          #+#    #+#             */
shared_libft/srcs/ft_memdel.c:/*   Updated: 2020/03/08 13:56:43 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_memset.c:	while (len--)
shared_libft/srcs/ft_printf/ft_char_conv.c:	c[0] = (char)argument->spec;
shared_libft/srcs/ft_printf/ft_char_conv.c:	argument->arg = c;
shared_libft/srcs/ft_printf/ft_char_conv.c:	argument->spec = 'C';
shared_libft/srcs/ft_printf/ft_char_conv.c:		if (argument->flags[4])
shared_libft/srcs/ft_printf/ft_char_conv.c:		ft_nputchar(' ', argument->flags[1] - 1, argument);
shared_libft/srcs/ft_printf/ft_char_conv.c:		if (!argument->flags[4])
shared_libft/srcs/ft_printf/ft_char_conv.c:	if (!(argument->arg = ft_strnew(4)))
shared_libft/srcs/ft_printf/ft_char_conv.c:	ft_wchartostr(argument->arg, (wchar_t)c);
shared_libft/srcs/ft_printf/ft_char_conv.c:	if (argument->spec == 'C' || argument->flags[10] == 1)
shared_libft/srcs/ft_printf/ft_char_conv.c:	argument->arg = c;
shared_libft/srcs/ft_printf/ft_char_conv.c:	if (argument->flags[1] > len)
shared_libft/srcs/ft_printf/ft_char_conv.c:		padding = argument->flags[1] - len;
shared_libft/srcs/ft_printf/ft_char_conv.c:	if (argument->flags[4] == 0 && argument->flags[3] == 0)
shared_libft/srcs/ft_printf/ft_char_conv.c:	if (argument->flags[3] == 1 && argument->flags[4] == 0)
shared_libft/srcs/ft_printf/ft_char_conv.c:	if (!argument->arg || argument->arg[0] == 0)
shared_libft/srcs/ft_printf/ft_char_conv.c:		ft_buff(argument->arg, argument);
shared_libft/srcs/ft_printf/ft_char_conv.c:	if (argument->flags[4] == 1)
shared_libft/srcs/ft_printf/ft_dprintf.c:		return (-1);
shared_libft/srcs/ft_printf/ft_flags.c:	i = argu->index;
shared_libft/srcs/ft_printf/ft_flags.c:	if (ft_isdigit(argu->format[argu->index])
shared_libft/srcs/ft_printf/ft_flags.c:		&& argu->format[argu->index] != '0')
shared_libft/srcs/ft_printf/ft_flags.c:		while (ft_isdigit(argu->format[argu->index]))
shared_libft/srcs/ft_printf/ft_flags.c:			argu->index++;
shared_libft/srcs/ft_printf/ft_flags.c:		argu->flags[1] = 0;
shared_libft/srcs/ft_printf/ft_flags.c:		if (argu->index - i > 0)
shared_libft/srcs/ft_printf/ft_flags.c:			str = ft_strsub(argu->format, (unsigned char)i, argu->index - i);
shared_libft/srcs/ft_printf/ft_flags.c:			argu->flags[1] = (int8_t)ft_atoi((const char*)str);
shared_libft/srcs/ft_printf/ft_flags.c:	return (argu->index);
shared_libft/srcs/ft_printf/ft_flags.c:	if (argument->format[argument->index] == '.')
shared_libft/srcs/ft_printf/ft_flags.c:		i = ++argument->index;
shared_libft/srcs/ft_printf/ft_flags.c:		argument->flags[0] = 0;
shared_libft/srcs/ft_printf/ft_flags.c:		if (argument->format[argument->index] == '*')
shared_libft/srcs/ft_printf/ft_flags.c:		i = argument->index;
shared_libft/srcs/ft_printf/ft_flags.c:		while (ft_isdigit(argument->format[argument->index]))
shared_libft/srcs/ft_printf/ft_flags.c:			argument->index++;
shared_libft/srcs/ft_printf/ft_flags.c:		if (argument->index - i > 0)
shared_libft/srcs/ft_printf/ft_flags.c:			str = ft_strsub(argument->format,
shared_libft/srcs/ft_printf/ft_flags.c:					(unsigned int)i, argument->index - i);
shared_libft/srcs/ft_printf/ft_flags.c:			argument->flags[0] = (int8_t)ft_atoi((const char*)str);
shared_libft/srcs/ft_printf/ft_flags.c:	return (argument->index);
shared_libft/srcs/ft_printf/ft_flags.c:	while (argu->format[argu->index] == '-' || argu->format[argu->index] == '+'
shared_libft/srcs/ft_printf/ft_flags.c:		|| argu->format[argu->index] == ' ' || argu->format[argu->index] == '#'
shared_libft/srcs/ft_printf/ft_flags.c:		|| argu->format[argu->index] == '0')
shared_libft/srcs/ft_printf/ft_flags.c:		if (argu->format[argu->index] == '#')
shared_libft/srcs/ft_printf/ft_flags.c:			argu->flags[2] = 1;
shared_libft/srcs/ft_printf/ft_flags.c:		if (argu->format[argu->index] == '0')
shared_libft/srcs/ft_printf/ft_flags.c:			argu->flags[3] = 1;
shared_libft/srcs/ft_printf/ft_flags.c:		if (argu->format[argu->index] == '-')
shared_libft/srcs/ft_printf/ft_flags.c:			argu->flags[4] = 1;
shared_libft/srcs/ft_printf/ft_flags.c:		if (argu->format[argu->index] == '+')
shared_libft/srcs/ft_printf/ft_flags.c:			argu->flags[5] = 1;
shared_libft/srcs/ft_printf/ft_flags.c:		if (argu->format[argu->index] == ' ')
shared_libft/srcs/ft_printf/ft_flags.c:			argu->flags[6] = 1;
shared_libft/srcs/ft_printf/ft_flags.c:		argu->index++;
shared_libft/srcs/ft_printf/ft_flags.c:	return (argu->index);
shared_libft/srcs/ft_printf/ft_flags.c:	while (argu->format[argu->index] == 'h' || argu->format[argu->index] == 'l'
shared_libft/srcs/ft_printf/ft_flags.c:		|| argu->format[argu->index] == 'z' || argu->format[argu->index] == 'j')
shared_libft/srcs/ft_printf/ft_flags.c:		if (argu->format[argu->index] == 'z')
shared_libft/srcs/ft_printf/ft_flags.c:			argu->flags[12] = 1;
shared_libft/srcs/ft_printf/ft_flags.c:		else if (argu->format[argu->index] == 'j')
shared_libft/srcs/ft_printf/ft_flags.c:			argu->flags[11] = 1;
shared_libft/srcs/ft_printf/ft_flags.c:		else if (argu->format[argu->index] == 'h'
shared_libft/srcs/ft_printf/ft_flags.c:			&& argu->format[argu->index + 1] == 'h')
shared_libft/srcs/ft_printf/ft_flags.c:			argu->flags[7] = 1;
shared_libft/srcs/ft_printf/ft_flags.c:			argu->index++;
shared_libft/srcs/ft_printf/ft_flags.c:		else if (argu->format[argu->index] == 'h')
shared_libft/srcs/ft_printf/ft_flags.c:			argu->flags[8] = 1;
shared_libft/srcs/ft_printf/ft_flags.c:		else if (argu->format[argu->index] == 'l'
shared_libft/srcs/ft_printf/ft_flags.c:			&& argu->format[argu->index + 1] == 'l')
shared_libft/srcs/ft_printf/ft_flags.c:			argu->flags[9] = 1;
shared_libft/srcs/ft_printf/ft_flags.c:			argu->index++;
shared_libft/srcs/ft_printf/ft_flags.c:		else if (argu->format[argu->index] == 'l')
shared_libft/srcs/ft_printf/ft_flags.c:			argu->flags[10] = 1;
shared_libft/srcs/ft_printf/ft_flags.c:		argu->index++;
shared_libft/srcs/ft_printf/ft_flags.c:	if (argument->format[argument->index] == 's')
shared_libft/srcs/ft_printf/ft_flags.c:		argument->spec = 's';
shared_libft/srcs/ft_printf/ft_flags.c:	else if (argument->format[argument->index] == 'S')
shared_libft/srcs/ft_printf/ft_flags.c:		argument->spec = 'S';
shared_libft/srcs/ft_printf/ft_flags.c:	else if (argument->format[argument->index] == 'p')
shared_libft/srcs/ft_printf/ft_flags.c:		argument->spec = 'p';
shared_libft/srcs/ft_printf/ft_flags.c:	else if (argument->format[argument->index] == 'd')
shared_libft/srcs/ft_printf/ft_flags.c:		argument->spec = 'd';
shared_libft/srcs/ft_printf/ft_flags.c:	else if (argument->format[argument->index] == 'D')
shared_libft/srcs/ft_printf/ft_flags.c:		argument->spec = 'D';
shared_libft/srcs/ft_printf/ft_flags.c:	else if (argument->format[argument->index] == 'i')
shared_libft/srcs/ft_printf/ft_flags.c:		argument->spec = 'i';
shared_libft/srcs/ft_printf/ft_flags.c:	else if (argument->format[argument->index] == 'o')
shared_libft/srcs/ft_printf/ft_flags.c:		argument->spec = 'o';
shared_libft/srcs/ft_printf/ft_flags.c:	else if (argument->format[argument->index] == 'O')
shared_libft/srcs/ft_printf/ft_flags.c:		argument->spec = 'O';
shared_libft/srcs/ft_printf/ft_flags.c:	else if (argument->format[argument->index] == 'u')
shared_libft/srcs/ft_printf/ft_flags.c:		argument->spec = 'u';
shared_libft/srcs/ft_printf/ft_flags.c:	else if (argument->format[argument->index] == 'U')
shared_libft/srcs/ft_printf/ft_flags.c:		argument->spec = 'U';
shared_libft/srcs/ft_printf/ft_flags.c:	else if (argument->format[argument->index] == 'x')
shared_libft/srcs/ft_printf/ft_flags.c:		argument->spec = 'x';
shared_libft/srcs/ft_printf/ft_flags.c:	else if (argument->format[argument->index] == 'X')
shared_libft/srcs/ft_printf/ft_flags.c:		argument->spec = 'X';
shared_libft/srcs/ft_printf/ft_float_conv.c:	if (argument->format[argument->index] == '*')
shared_libft/srcs/ft_printf/ft_float_conv.c:		argument->flags[i] = (int8_t)va_arg(ap, int);
shared_libft/srcs/ft_printf/ft_float_conv.c:		if (argument->flags[i] < 0)
shared_libft/srcs/ft_printf/ft_float_conv.c:				argument->flags[4] = 1;
shared_libft/srcs/ft_printf/ft_float_conv.c:				argument->flags[1] *= -1;
shared_libft/srcs/ft_printf/ft_float_conv.c:				argument->flags[0] = -1;
shared_libft/srcs/ft_printf/ft_float_conv.c:				argument->index++;
shared_libft/srcs/ft_printf/ft_float_conv.c:		argument->index++;
shared_libft/srcs/ft_printf/ft_float_conv.c:		tt = tt - (u_int64_t)tt;
shared_libft/srcs/ft_printf/ft_float_conv.c:		nf = nf - (u_int64_t)nf;
shared_libft/srcs/ft_printf/ft_float_conv.c:	argument->arg = ft_strncat(argument->arg, tmp, precision);
shared_libft/srcs/ft_printf/ft_float_conv.c:	return (argument->arg);
shared_libft/srcs/ft_printf/ft_float_conv.c:	argument->arg = ft_itoa_base_custom((u_int64_t)nbr, 10);
shared_libft/srcs/ft_printf/ft_float_conv.c:	if (precision || argument->flags[2])
shared_libft/srcs/ft_printf/ft_float_conv.c:		argument->arg = ft_strncat(argument->arg, ".", 1);
shared_libft/srcs/ft_printf/ft_float_conv.c:		argument->arg = ft_getipart(nbr, argument, precision);
shared_libft/srcs/ft_printf/ft_float_conv.c:	argument->flags[0] = -1;
shared_libft/srcs/ft_printf/ft_float_conv.c:	return (argument->arg);
shared_libft/srcs/ft_printf/ft_float_conv.c:	argument->spec = 'f';
shared_libft/srcs/ft_printf/ft_float_conv.c:	if (argument->flags[0] == -1)
shared_libft/srcs/ft_printf/ft_float_conv.c:		precision = (size_t)argument->flags[0];
shared_libft/srcs/ft_printf/ft_float_conv.c:		argument->arg = ft_ftoa(n, argument, precision);
shared_libft/srcs/ft_printf/ft_float_conv.c:		argument->arg = ft_ftoa(-n, argument, precision);
shared_libft/srcs/ft_printf/ft_float_conv.c:		return (ft_print_number(argument, "-"));
shared_libft/srcs/ft_printf/ft_float_conv.c:	if (argument->flags[5])
shared_libft/srcs/ft_printf/ft_float_conv.c:	if (argument->flags[6])
shared_libft/srcs/ft_printf/ft_memory.c:		argument->flags[i] = 0;
shared_libft/srcs/ft_printf/ft_memory.c:	argument->flags[0] = -1;
shared_libft/srcs/ft_printf/ft_memory.c:	argument->flags[1] = -1;
shared_libft/srcs/ft_printf/ft_memory.c:	argument->format = NULL;
shared_libft/srcs/ft_printf/ft_memory.c:	argument->index = 0;
shared_libft/srcs/ft_printf/ft_memory.c:	argument->spec = ' ';
shared_libft/srcs/ft_printf/ft_memory.c:	argument->arg = NULL;
shared_libft/srcs/ft_printf/ft_memory.c:	argument->warg = NULL;
shared_libft/srcs/ft_printf/ft_memory.c:		spe->spe[i++] = ft_arg_nospe;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['p'] = pointer_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['s'] = string_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['S'] = string_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['c'] = character_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['C'] = character_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['d'] = signed_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['D'] = signed_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['i'] = signed_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['o'] = unsigned_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['O'] = unsigned_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['u'] = unsigned_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['U'] = unsigned_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['%'] = prc_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['x'] = unsigned_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['X'] = unsigned_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['b'] = unsigned_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['f'] = float_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	spe->spe['F'] = float_handler;
shared_libft/srcs/ft_printf/ft_memory.c:	if (argument->format[argument->index] == 'c')
shared_libft/srcs/ft_printf/ft_memory.c:		argument->spec = 'c';
shared_libft/srcs/ft_printf/ft_memory.c:	else if (argument->format[argument->index] == 'C')
shared_libft/srcs/ft_printf/ft_memory.c:		argument->spec = 'C';
shared_libft/srcs/ft_printf/ft_memory.c:	else if (argument->format[argument->index] == 'f')
shared_libft/srcs/ft_printf/ft_memory.c:		argument->spec = 'f';
shared_libft/srcs/ft_printf/ft_memory.c:	else if (argument->format[argument->index] == 'F')
shared_libft/srcs/ft_printf/ft_memory.c:		argument->spec = 'f';
shared_libft/srcs/ft_printf/ft_memory.c:		argument->spec = (unsigned char)argument->format[argument->index];
shared_libft/srcs/ft_printf/ft_memory.c:	return (argument->index);
shared_libft/srcs/ft_printf/ft_printf.c:/*   Updated: 2020/03/08 14:11:24 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_printf/ft_printf.c:	argu->index = 0;
shared_libft/srcs/ft_printf/ft_printf.c:	while (argu->format[argu->index] == '#' || argu->format[argu->index] == '0'
shared_libft/srcs/ft_printf/ft_printf.c:		|| argu->format[argu->index] == '-' || argu->format[argu->index] == '+'
shared_libft/srcs/ft_printf/ft_printf.c:		|| argu->format[argu->index] == ' ' || argu->format[argu->index] == 'h'
shared_libft/srcs/ft_printf/ft_printf.c:		|| argu->format[argu->index] == 'l' || argu->format[argu->index] == 'j'
shared_libft/srcs/ft_printf/ft_printf.c:		|| argu->format[argu->index] == 'z' || argu->format[argu->index] == '.'
shared_libft/srcs/ft_printf/ft_printf.c:		|| argu->format[argu->index] == '*' ||
shared_libft/srcs/ft_printf/ft_printf.c:		ft_isdigit(argu->format[argu->index]))
shared_libft/srcs/ft_printf/ft_printf.c:	if (argu->index == ft_strlen(argu->format))
shared_libft/srcs/ft_printf/ft_printf.c:			argument->format = &str[++i];
shared_libft/srcs/ft_printf/ft_printf.c:			spe->spe[argument->spec](argument, ap);
shared_libft/srcs/ft_printf/ft_printf.c:			i += argument->index;
shared_libft/srcs/ft_printf/ft_printf.c:		return (-1);
shared_libft/srcs/ft_printf/ft_signed_conv.c:	if (argument->flags[12] == 1)
shared_libft/srcs/ft_printf/ft_signed_conv.c:	else if (argument->flags[11] == 1)
shared_libft/srcs/ft_printf/ft_signed_conv.c:	else if (argument->flags[9] == 1)
shared_libft/srcs/ft_printf/ft_signed_conv.c:	else if (argument->flags[10] == 1)
shared_libft/srcs/ft_printf/ft_signed_conv.c:	else if (argument->flags[8] == 1)
shared_libft/srcs/ft_printf/ft_signed_conv.c:	else if (argument->flags[7] == 1)
shared_libft/srcs/ft_printf/ft_signed_conv.c:	if (!args->arg)
shared_libft/srcs/ft_printf/ft_signed_conv.c:	if (args->spec == 'o' || args->spec == 'O')
shared_libft/srcs/ft_printf/ft_signed_conv.c:	if (args->arg[0] == '0' && !args->arg[1] && args->flags[0] == 0)
shared_libft/srcs/ft_printf/ft_signed_conv.c:		if (!octal || (octal && !args->flags[2]))
shared_libft/srcs/ft_printf/ft_signed_conv.c:			ft_strdel(&args->arg);
shared_libft/srcs/ft_printf/ft_signed_conv.c:			args->arg = ft_strdup("");
shared_libft/srcs/ft_printf/ft_signed_conv.c:	n = (argument->spec == 'd' || argument->spec == 'i') ?
shared_libft/srcs/ft_printf/ft_signed_conv.c:		argument->arg = ft_itoa_base_custom((u_int64_t)n, 10);
shared_libft/srcs/ft_printf/ft_signed_conv.c:		argument->arg = ft_itoa_base_custom(-(u_int64_t)n, 10);
shared_libft/srcs/ft_printf/ft_signed_conv.c:		return (ft_print_number(argument, "-"));
shared_libft/srcs/ft_printf/ft_signed_conv.c:	if (argument->flags[5])
shared_libft/srcs/ft_printf/ft_signed_conv.c:	if (argument->flags[6])
shared_libft/srcs/ft_printf/ft_signed_conv.c:	ft_buff(argument->arg, argument);
shared_libft/srcs/ft_printf/ft_signed_conv.c:	if (argument->flags[4] == 1)
shared_libft/srcs/ft_printf/ft_signed_conv.c:	ft_strdel(&argument->arg);
shared_libft/srcs/ft_printf/ft_signed_conv.c:	len = (ssize_t)ft_strlen(argument->arg);
shared_libft/srcs/ft_printf/ft_signed_conv.c:	if (argument->flags[0] > len)
shared_libft/srcs/ft_printf/ft_signed_conv.c:		precision = (ssize_t)argument->flags[0] - len;
shared_libft/srcs/ft_printf/ft_signed_conv.c:	if (argument->flags[1] > len)
shared_libft/srcs/ft_printf/ft_signed_conv.c:		padding = (ssize_t)argument->flags[1] - len;
shared_libft/srcs/ft_printf/ft_signed_conv.c:	if (argument->flags[4] == 0 && (argument->flags[3] == 0
shared_libft/srcs/ft_printf/ft_signed_conv.c:		|| argument->flags[0] != -1))
shared_libft/srcs/ft_printf/ft_signed_conv.c:	if (argument->flags[3] == 1 && argument->flags[4] == 0
shared_libft/srcs/ft_printf/ft_signed_conv.c:		&& argument->flags[0] == -1)
shared_libft/srcs/ft_printf/ft_str_conv.c:/*   Updated: 2020/03/08 14:11:35 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_printf/ft_str_conv.c:	argument->ret += write(argument->fd, &g_buff, g_i);
shared_libft/srcs/ft_printf/ft_str_conv.c:	argument->warg = va_arg(ap, wchar_t *);
shared_libft/srcs/ft_printf/ft_str_conv.c:	argument->spec = 'S';
shared_libft/srcs/ft_printf/ft_str_conv.c:	if (!argument->warg)
shared_libft/srcs/ft_printf/ft_str_conv.c:		argument->warg = L"(null)";
shared_libft/srcs/ft_printf/ft_str_conv.c:	len = (ssize_t)ft_wbytelen(argument->warg);
shared_libft/srcs/ft_printf/ft_str_conv.c:	if (argument->flags[0] > -1 && argument->flags[0] < len)
shared_libft/srcs/ft_printf/ft_str_conv.c:		argument->arg = ft_wstrsub(argument->warg,
shared_libft/srcs/ft_printf/ft_str_conv.c:							0, (size_t)argument->flags[0]);
shared_libft/srcs/ft_printf/ft_str_conv.c:		argument->arg = ft_transform_wchar_in_char(argument->warg);
shared_libft/srcs/ft_printf/ft_str_conv.c:	if (argument->spec == 'S' || argument->flags[10] == 1)
shared_libft/srcs/ft_printf/ft_str_conv.c:		argument->arg = ft_strdup("(null)");
shared_libft/srcs/ft_printf/ft_str_conv.c:		if (argument->flags[0] > -1 && argument->flags[0] < len)
shared_libft/srcs/ft_printf/ft_str_conv.c:			argument->arg = ft_strsub(tmp, 0, (size_t)argument->flags[0]);
shared_libft/srcs/ft_printf/ft_str_conv.c:			argument->arg = ft_strdup(tmp);
shared_libft/srcs/ft_printf/ft_str_conv.c:	if (!argument->arg)
shared_libft/srcs/ft_printf/ft_str_conv.c:	len = (ssize_t)ft_strlen(argument->arg);
shared_libft/srcs/ft_printf/ft_str_conv.c:	if (argument->flags[0] > -1 && argument->flags[0] < len)
shared_libft/srcs/ft_printf/ft_str_conv.c:		len = argument->flags[0];
shared_libft/srcs/ft_printf/ft_str_conv.c:	if (argument->flags[1] > len)
shared_libft/srcs/ft_printf/ft_str_conv.c:		padding = argument->flags[1] - len;
shared_libft/srcs/ft_printf/ft_str_conv.c:	if (argument->flags[4] == 0 && argument->flags[3] == 0)
shared_libft/srcs/ft_printf/ft_str_conv.c:	if (argument->flags[3] == 1 && argument->flags[4] == 0)
shared_libft/srcs/ft_printf/ft_str_conv.c:	ft_buff(argument->arg, argument);
shared_libft/srcs/ft_printf/ft_str_conv.c:	if (argument->flags[4] == 1)
shared_libft/srcs/ft_printf/ft_str_conv.c:	ft_strdel(&argument->arg);
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	if (argument->flags[7] == 1)
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	else if (argument->flags[8] == 1)
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	else if (argument->flags[10] == 1)
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	else if (argument->flags[9] == 1)
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	else if (argument->flags[11] == 1)
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	else if (argument->flags[12] == 1)
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	len = (ssize_t)ft_strlen(argument->arg);
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	nullstr = (len == 1 && !ft_strcmp(argument->arg, "0")) ? 0 : 1;
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	if (argument->flags[2] == 1)
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:		if (argument->spec == 'o' || argument->spec == 'O')
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:			if (argument->flags[0] <= len && ft_strcmp(argument->arg, "0") != 0)
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:		else if (argument->spec == 'x' && nullstr != 0)
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:		else if (argument->spec == 'X' && nullstr != 0)
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	if (argument->spec == 'x' || argument->spec == 'X'
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:		|| argument->spec == 'u' || argument->spec == 'o'
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:		|| argument->spec == 'b')
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	if (argument->spec == 'o' || argument->spec == 'O')
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:		argument->arg = ft_itoa_base_custom(n, 8);
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	else if (argument->spec == 'u' || argument->spec == 'U')
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:		argument->arg = ft_itoa_base_custom(n, 10);
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	else if (argument->spec == 'x')
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:		argument->arg = ft_strlower(ft_itoa_base_custom(n, 16));
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	else if (argument->spec == 'b')
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:		argument->arg = ft_itoa_base_custom(n, 2);
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:		argument->arg = ft_itoa_base_custom(n, 16);
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	argument->arg = "%";
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	argument->arg = ft_itoa_base_custom(n, 16);
shared_libft/srcs/ft_printf/ft_unsigned_conv.c:	argument->arg = ft_strlower(argument->arg);
shared_libft/srcs/ft_printf/ft_wstrsub.c:		len -= ft_wcharlen(ws[i]);
shared_libft/srcs/ft_printf/ft_wstrtostr.c:/*   Updated: 2020/03/08 14:11:49 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_putchar_fd.c:/*   Updated: 2020/03/08 13:57:10 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_putnbr_fd.c:		ft_putchar_fd('-', fd);
shared_libft/srcs/ft_putnbr_fd.c:		nb = -nb;
shared_libft/srcs/ft_putstr_fd.c:/*   Updated: 2020/03/08 13:57:34 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_strcmp.c:			? ft_strcmp(++s1, ++s2) : (unsigned char)*s1 - (unsigned char)*s2);
shared_libft/srcs/ft_strdel.c:/*   Updated: 2020/03/08 13:57:54 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_strjoinf.c:/*   Updated: 2020/03/08 13:58:23 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_strlen.c:/*   Updated: 2020/02/22 18:36:05 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_strncat.c:		n--;
shared_libft/srcs/ft_strncmp.c:	return ((unsigned char)*s1 - (unsigned char)*s2);
shared_libft/srcs/ft_strnequ.c:	while (n-- && *s1 && *s2)
shared_libft/srcs/ft_strrchr.c:		i--;
shared_libft/srcs/ft_strsub_free.c:/*   Updated: 2020/03/08 13:58:49 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_strsub_free.c:		len--;
shared_libft/srcs/ft_tabchr.c:/*   Created: 2019/09/30 00:50:59 by mpivet-p          #+#    #+#             */
shared_libft/srcs/ft_tabcopy.c:/*   Updated: 2020/03/08 13:59:30 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_tabdel.c:/*   Updated: 2020/03/08 14:00:31 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_tabfree.c:/*   Updated: 2020/03/08 14:00:40 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/ft_wcharlen.c:		len--;
shared_libft/srcs/get_next_line.c:/*   Created: 2020/02/22 14:43:41 by mpivet-p          #+#    #+#             */
shared_libft/srcs/get_next_line.c:			i = (size_t)(ft_strchr(buffer, '\n') - buffer);
shared_libft/srcs/get_next_line.c:		return (-1);
shared_libft/srcs/get_next_line.c:		i = (size_t)(ft_strchr(buffer, '\n') - buffer);
shared_libft/srcs/remove_invalid_char.c:/*   Created: 2020/02/22 18:53:19 by mpivet-p          #+#    #+#             */
shared_libft/srcs/skip_options.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
shared_libft/srcs/skip_options.c:/*   Created: 2020/02/09 03:46:53 by mpivet-p          #+#    #+#             */
shared_libft/srcs/skip_options.c:/*   Updated: 2020/03/10 18:48:24 by mpivet-p         ###   ########.fr       */
shared_libft/srcs/skip_options.c:	while (argv[i] && argv[i][0] == '-')
shared_libft/srcs/skip_options.c:		if (ft_strcmp(argv[i], "--"))
srcs/LPA/analyzer/analyze.c:/*   Updated: 2020/03/08 15:36:39 by mpivet-p         ###   ########.fr       */
srcs/LPA/analyzer/analyze.c:	analyzer->state = A_STOP;
srcs/LPA/analyzer/analyze.c:	anal->state = A_IONUMBER;
srcs/LPA/analyzer/analyze.c:	anal->job.command = fill_cmd_job(anal->lexer, anal->job.command);
srcs/LPA/analyzer/analyze.c:	anal->redir.op[0] = ft_strdup(((t_token*)anal->lexer->content)->data);
srcs/LPA/analyzer/analyze.c:	anal->state = A_STOP;
srcs/LPA/analyzer/analyze.c:	shell->status = 2;
srcs/LPA/analyzer/analyze.c:	state = ((t_token*)anal->lexer->content)->id;
srcs/LPA/analyzer/analyze.c:		anal->job.type = state;
srcs/LPA/analyzer/analyze.c:		anal->job.command = fill_cmd_job(anal->lexer, anal->job.command);
srcs/LPA/analyzer/analyze.c:		anal->process.type = state;
srcs/LPA/analyzer/analyze.c:		anal->state = A_SEPARATOR;
srcs/LPA/analyzer/analyze.c:		anal->process.command = fill_cmd_job(anal->lexer,
srcs/LPA/analyzer/analyze.c:			anal->process.command);
srcs/LPA/analyzer/analyze.c:		anal->job.type = state;
srcs/LPA/analyzer/analyze.c:	anal->state = A_SEPARATOR;
srcs/LPA/analyzer/analyze.c:	while (anal->state != A_STOP)
srcs/LPA/analyzer/analyze.c:		anal = anal->analyze[anal->state]
srcs/LPA/analyzer/analyze.c:			[((t_token*)anal->lexer->content)->id](anal, shell);
srcs/LPA/analyzer/analyze.c:		anal->lexer = anal->lexer->next;
srcs/LPA/analyzer/analyze.c:	free(anal->job.command);
srcs/LPA/analyzer/analyze.c:	shell->job_list = anal->job_list;
srcs/LPA/analyzer/analyzer_assign.c:	db->key = NULL;
srcs/LPA/analyzer/analyzer_assign.c:	db->value = NULL;
srcs/LPA/analyzer/analyzer_assign.c:	db->type = 0;
srcs/LPA/analyzer/analyzer_assign.c:	ft_lstappend(&anal->process.assign_list,
srcs/LPA/analyzer/analyzer_assign.c:		ft_lstnew(fetch_db(&anal->db,
srcs/LPA/analyzer/analyzer_assign.c:		((t_token*)anal->lexer->content)->data,
srcs/LPA/analyzer/analyzer_assign.c:	init_assign(&anal->db);
srcs/LPA/analyzer/analyzer_assign.c:	anal->process.type = ((t_token*)anal->lexer->content)->id;
srcs/LPA/analyzer/analyzer_assign.c:	anal->state = A_ASSIGN;
srcs/LPA/analyzer/analyzer_assign.c:	if (((t_token*)anal->lexer->content)->id == P_ASSIGN
srcs/LPA/analyzer/analyzer_assign.c:		&& ((anal->state != A_WORD)))
srcs/LPA/analyzer/analyzer_assign.c:		anal->job.command = fill_cmd_job(anal->lexer, anal->job.command);
srcs/LPA/analyzer/analyzer_assign.c:		anal->state = A_WORD;
srcs/LPA/analyzer/analyzer_heredoc.c:/*   Updated: 2020/03/08 15:39:11 by mpivet-p         ###   ########.fr       */
srcs/LPA/analyzer/analyzer_heredoc.c:	while (exp->st != E_END)
srcs/LPA/analyzer/analyzer_heredoc.c:		exp = exp->biteurs[exp->st](data, shell, exp);
srcs/LPA/analyzer/analyzer_heredoc.c:	resultat = ft_strdup(exp->res);
srcs/LPA/analyzer/analyzer_heredoc.c:	ft_strdel(&exp->res);
srcs/LPA/analyzer/analyzer_heredoc.c:	anal->redir.type = ((t_token*)anal->lexer->content)->id;
srcs/LPA/analyzer/analyzer_heredoc.c:	anal->lexer = anal->lexer->next;
srcs/LPA/analyzer/analyzer_heredoc.c:	anal->job.command = fill_cmd_job(anal->lexer, anal->job.command);
srcs/LPA/analyzer/analyzer_heredoc.c:	anal->lexer = anal->lexer->next;
srcs/LPA/analyzer/analyzer_heredoc.c:	anal->job.command = fill_cmd_job(anal->lexer, anal->job.command);
srcs/LPA/analyzer/analyzer_heredoc.c:	anal->redir.op[1] = ft_strdup(((t_token*)anal->lexer->content)->data);
srcs/LPA/analyzer/analyzer_heredoc.c:	anal->redir.heredoc = ft_strjoin(anal->redir.op[1], "\n");
srcs/LPA/analyzer/analyzer_heredoc.c:	anal->state = A_WORD;
srcs/LPA/analyzer/analyzer_heredoc.c:		&& ft_strcmp(line, anal->redir.op[1]) != 0)
srcs/LPA/analyzer/analyzer_heredoc.c:		if (!anal->redir.heredoc)
srcs/LPA/analyzer/analyzer_heredoc.c:			anal->redir.heredoc = ft_strdup(line);
srcs/LPA/analyzer/analyzer_heredoc.c:			anal->redir.heredoc = ft_strjoinf(anal->redir.heredoc, line, 4);
srcs/LPA/analyzer/analyzer_heredoc.c:		anal->redir.heredoc = ft_strjoinf(anal->redir.heredoc, "\n", 1);
srcs/LPA/analyzer/analyzer_heredoc.c:	shell->heredoc = 1;
srcs/LPA/analyzer/analyzer_heredoc.c:	anal->redir.op[1] = heredoc_inhib(((t_token*)anal->lexer->content)->data);
srcs/LPA/analyzer/analyzer_heredoc.c:	if (shell->is_interactive)
srcs/LPA/analyzer/analyzer_heredoc.c:		anal->redir.heredoc = load_heredoc(shell, anal->redir.op[1]);
srcs/LPA/analyzer/analyzer_heredoc.c:	if (!shell->heredoc)
srcs/LPA/analyzer/analyzer_heredoc.c:	anal->state = A_WORD;
srcs/LPA/analyzer/analyzer_heredoc.c:	shell->term.flag = FALSE;
srcs/LPA/analyzer/analyzer_heredoc.c:	shell->term.status = CMD_DONE;
srcs/LPA/analyzer/analyzer_job.c:	new->type = P_END;
srcs/LPA/analyzer/analyzer_job.c:	anal->job.process_list = anal->process_list;
srcs/LPA/analyzer/analyzer_job.c:	ft_lstappend(&anal->job_list,
srcs/LPA/analyzer/analyzer_job.c:		ft_lstnew(&anal->job, sizeof(t_job)));
srcs/LPA/analyzer/analyzer_job.c:	anal->process_list = NULL;
srcs/LPA/analyzer/analyzer_job.c:	init_job(&anal->job);
srcs/LPA/analyzer/analyzer_job.c:	if (anal->lexer->next
srcs/LPA/analyzer/analyzer_job.c:		&& ((t_token*)anal->lexer->next->content)->id == P_END)
srcs/LPA/analyzer/analyzer_job.c:		anal->state = A_STOP;
srcs/LPA/analyzer/analyzer_job.c:		anal->state = A_START;
srcs/LPA/analyzer/analyzer_memory.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/LPA/analyzer/analyzer_memory.c:/*   Updated: 2020/03/08 15:39:28 by mpivet-p         ###   ########.fr       */
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->redir.op[0])
srcs/LPA/analyzer/analyzer_memory.c:		ft_strdel(&anal->redir.op[0]);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->redir.op[1])
srcs/LPA/analyzer/analyzer_memory.c:		ft_strdel(&anal->redir.op[1]);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->redir.heredoc)
srcs/LPA/analyzer/analyzer_memory.c:		ft_strdel(&anal->redir.heredoc);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->redir_list)
srcs/LPA/analyzer/analyzer_memory.c:		ft_free_redirlist(&anal->redir_list);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->db.key)
srcs/LPA/analyzer/analyzer_memory.c:		ft_strdel(&anal->db.key);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->db.value)
srcs/LPA/analyzer/analyzer_memory.c:		ft_strdel(&anal->db.value);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->process.redir_list)
srcs/LPA/analyzer/analyzer_memory.c:		ft_free_redirlist(&anal->process.redir_list);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->process.assign_list)
srcs/LPA/analyzer/analyzer_memory.c:		free_db(anal->process.assign_list);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->process.command)
srcs/LPA/analyzer/analyzer_memory.c:		ft_strdel(&anal->process.command);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->process.tok_list)
srcs/LPA/analyzer/analyzer_memory.c:		ft_freetokenlist(&anal->process.tok_list);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->process_list)
srcs/LPA/analyzer/analyzer_memory.c:		free_process_list(&anal->process_list);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->job.command)
srcs/LPA/analyzer/analyzer_memory.c:		ft_strdel(&anal->job.command);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->job.process_list)
srcs/LPA/analyzer/analyzer_memory.c:		free_process_list(&anal->job.process_list);
srcs/LPA/analyzer/analyzer_memory.c:	if (anal->job_list)
srcs/LPA/analyzer/analyzer_memory.c:		ft_freejoblist(&anal->job_list);
srcs/LPA/analyzer/analyzer_memory.c:	anal->state = A_STOP;
srcs/LPA/analyzer/analyzer_memory.c:	anal->job_list = NULL;
srcs/LPA/analyzer/analyzer_memory.c:	shell->status = 2;
srcs/LPA/analyzer/analyzer_memory.c:	ft_strdel(&(redir->op[0]));
srcs/LPA/analyzer/analyzer_memory.c:	ft_strdel(&(redir->op[1]));
srcs/LPA/analyzer/analyzer_memory.c:	ft_strdel(&(redir->heredoc));
srcs/LPA/analyzer/analyzer_memory.c:		next = ptr->next;
srcs/LPA/analyzer/analyzer_memory.c:		ft_free_redir(ptr->content);
srcs/LPA/analyzer/analyzer_memory.c:		next = ptr->next;
srcs/LPA/analyzer/analyzer_memory.c:		ft_free_redirlist((t_lst **)&(((t_process *)ptr->content)->redir_list));
srcs/LPA/analyzer/analyzer_memory.c:		free_db((((t_process *)ptr->content)->assign_list));
srcs/LPA/analyzer/analyzer_memory.c:		ft_freetokenlist(&(((t_process *)ptr->content)->tok_list));
srcs/LPA/analyzer/analyzer_memory.c:		ft_tabdel(&(((t_process *)ptr->content)->av));
srcs/LPA/analyzer/analyzer_memory.c:		ft_tabdel(&(((t_process *)ptr->content)->envp));
srcs/LPA/analyzer/analyzer_memory.c:		ft_strdel(&(((t_process *)ptr->content)->bin));
srcs/LPA/analyzer/analyzer_memory.c:		ft_strdel(&(((t_process *)ptr->content)->command));
srcs/LPA/analyzer/analyzer_memory.c:		free(ptr->content);
srcs/LPA/analyzer/analyzer_name.c:	anal->job.command = fill_cmd_job(anal->lexer, anal->job.command);
srcs/LPA/analyzer/analyzer_name.c:	anal->process.command = fill_cmd_job(anal->lexer, anal->process.command);
srcs/LPA/analyzer/analyzer_name.c:	ft_lstappend(&anal->process.tok_list, ft_lstnew(fetch_token(&anal->tok,
srcs/LPA/analyzer/analyzer_name.c:		((t_token*)anal->lexer->content)->id,
srcs/LPA/analyzer/analyzer_name.c:		((t_token*)anal->lexer->content)->data), sizeof(t_token)));
srcs/LPA/analyzer/analyzer_name.c:	if (anal->state == A_REDIRECT)
srcs/LPA/analyzer/analyzer_name.c:	anal->state = A_WORD;
srcs/LPA/analyzer/analyzer_process.c:/*   Updated: 2020/03/11 20:35:53 by mpivet-p         ###   ########.fr       */
srcs/LPA/analyzer/analyzer_process.c:	new->type = P_START;
srcs/LPA/analyzer/analyzer_process.c:	new->pipe[0] = STDIN_FILENO;
srcs/LPA/analyzer/analyzer_process.c:	new->pipe[1] = STDOUT_FILENO;
srcs/LPA/analyzer/analyzer_process.c:	new->close[0] = -1;
srcs/LPA/analyzer/analyzer_process.c:	new->close[1] = -1;
srcs/LPA/analyzer/analyzer_process.c:	anal->process.redir_list = anal->redir_list;
srcs/LPA/analyzer/analyzer_process.c:	ft_lstappend(&anal->process_list,
srcs/LPA/analyzer/analyzer_process.c:		ft_lstnew(&anal->process, sizeof(t_process)));
srcs/LPA/analyzer/analyzer_process.c:	anal->redir_list = NULL;
srcs/LPA/analyzer/analyzer_process.c:	init_process(&anal->process);
srcs/LPA/analyzer/analyzer_process.c:	anal->state = A_SEPARATOR;
srcs/LPA/analyzer/analyzer_redir.c:	new->op[0] = NULL;
srcs/LPA/analyzer/analyzer_redir.c:	new->op[1] = NULL;
srcs/LPA/analyzer/analyzer_redir.c:	new->type = P_START;
srcs/LPA/analyzer/analyzer_redir.c:	new->heredoc = NULL;
srcs/LPA/analyzer/analyzer_redir.c:	anal->job.command = fill_cmd_job(anal->lexer, anal->job.command);
srcs/LPA/analyzer/analyzer_redir.c:	if (anal->redir.type == P_DLESS || anal->redir.type == P_DLESSDASH)
srcs/LPA/analyzer/analyzer_redir.c:		anal->redir.op[1] = ft_strdup(((t_token*)anal->lexer->content)->data);
srcs/LPA/analyzer/analyzer_redir.c:	anal->state = A_WORD;
srcs/LPA/analyzer/analyzer_redir.c:	ft_lstappend(&anal->redir_list,
srcs/LPA/analyzer/analyzer_redir.c:		ft_lstnew(&anal->redir, sizeof(t_redir)));
srcs/LPA/analyzer/analyzer_redir.c:	init_redir(&anal->redir);
srcs/LPA/analyzer/analyzer_redir.c:	anal->job.command = fill_cmd_job(anal->lexer, anal->job.command);
srcs/LPA/analyzer/analyzer_redir.c:	if ((((t_token*)anal->lexer->content)->id == P_DLESS && anal->lexer->next
srcs/LPA/analyzer/analyzer_redir.c:		&& ((t_token*)anal->lexer->next->content)->id == P_LESS))
srcs/LPA/analyzer/analyzer_redir.c:	anal->redir.type = ((t_token*)anal->lexer->content)->id;
srcs/LPA/analyzer/analyzer_redir.c:	anal->state = A_REDIRECT;
srcs/LPA/analyzer/init_analyzer.c:/*   Updated: 2020/03/08 15:39:53 by mpivet-p         ###   ########.fr       */
srcs/LPA/analyzer/init_analyzer.c:	bzero_analyze(analyzer->analyze);
srcs/LPA/analyzer/init_analyzer.c:	init_process(&analyzer->process);
srcs/LPA/analyzer/init_analyzer.c:	init_redir(&analyzer->redir);
srcs/LPA/analyzer/init_analyzer.c:	init_job(&analyzer->job);
srcs/LPA/analyzer/init_analyzer.c:	init_assign(&analyzer->db);
srcs/LPA/analyzer/init_analyzer.c:	init_start_analyze(analyzer->analyze);
srcs/LPA/analyzer/init_analyzer.c:	init_ionumber_analyze(analyzer->analyze);
srcs/LPA/analyzer/init_analyzer.c:	init_assign_analyze(analyzer->analyze);
srcs/LPA/analyzer/init_analyzer.c:	init_word_analyze(analyzer->analyze);
srcs/LPA/analyzer/init_analyzer.c:	init_separator_analyze(analyzer->analyze);
srcs/LPA/analyzer/init_analyzer.c:	init_redirect_analyze(analyzer->analyze);
srcs/LPA/analyzer/init_analyzer.c:	init_end_analyze(analyzer->analyze);
srcs/LPA/analyzer/init_analyzer.c:	analyzer->state = A_START;
srcs/LPA/analyzer/init_analyzer.c:	analyzer->lexer = lexer;
srcs/LPA/analyzer/init_analyzer.c:	analyzer->job_list = NULL;
srcs/LPA/analyzer/init_analyzer.c:	analyzer->redir_list = NULL;
srcs/LPA/analyzer/init_analyzer.c:	analyzer->process_list = NULL;
srcs/LPA/analyzer/token_to_tab.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/LPA/analyzer/token_to_tab.c:/*   Updated: 2020/03/08 15:40:11 by mpivet-p         ###   ########.fr       */
srcs/LPA/analyzer/token_to_tab.c:	if (!tok_lst || !tok_lst->content)
srcs/LPA/analyzer/token_to_tab.c:		cmd = ft_strdup(((t_token*)tok_lst->content)->data);
srcs/LPA/analyzer/token_to_tab.c:		cmd = ft_strjoinf(cmd, ((t_token*)tok_lst->content)->data, 1);
srcs/LPA/lexer/assign_token.c:	value_len = get_word_size_ntype(len, lex->buff);
srcs/LPA/lexer/assign_token.c:	if (!(str = ft_strsub(lex->buff, lex->buf_pos,
srcs/LPA/lexer/assign_token.c:		value_len - lex->buf_pos)))
srcs/LPA/lexer/assign_token.c:		ft_lstnew(fetch_token(&lex->token, P_ASSIGN, str), sizeof(t_token)))))
srcs/LPA/lexer/assign_token.c:	lex->ntok++;
srcs/LPA/lexer/assign_token.c:	lex->buf_pos = value_len;
srcs/LPA/lexer/assign_token.c:	if (!lexer->buff)
srcs/LPA/lexer/assign_token.c:		lexer->status = L_END;
srcs/LPA/lexer/assign_token.c:		if ((i = isvalid_assignement_word(lexer->buff, lexer->buf_pos)))
srcs/LPA/lexer/assign_token.c:	lexer->status = L_START;
srcs/LPA/lexer/init_lexer.c:	lexer->lex[L_START] = start_lexer;
srcs/LPA/lexer/init_lexer.c:	lexer->lex[L_OPERATOR] = operator_lexer;
srcs/LPA/lexer/init_lexer.c:	lexer->lex[L_NAME] = name_lexer;
srcs/LPA/lexer/init_lexer.c:	lexer->lex[L_IO_NUMBER] = number_lexer;
srcs/LPA/lexer/init_lexer.c:	lexer->lex[L_NEWLINE] = newline_lexer;
srcs/LPA/lexer/init_lexer.c:	lexer->lex[L_DISCARD] = discard_lexer;
srcs/LPA/lexer/init_lexer.c:	lexer->lex[L_ASSIGNEMENT_WORD] = assignement_word_lexer;
srcs/LPA/lexer/init_lexer.c:	lexer->lex[L_END] = end_lexer;
srcs/LPA/lexer/init_lexer.c:	new->buff = line;
srcs/LPA/lexer/init_lexer.c:	new->status = L_START;
srcs/LPA/lexer/init_lexer.c:	new->ntok = 0;
srcs/LPA/lexer/init_lexer.c:	new->buf_pos = 0;
srcs/LPA/lexer/init_lexer.c:	new->token.data = NULL;
srcs/LPA/lexer/init_lexer.c:	new->token.id = P_ERROR;
srcs/LPA/lexer/init_lexer.c:	token->id = type;
srcs/LPA/lexer/init_lexer.c:	if (!(token->data = ft_strdup(data)))
srcs/LPA/lexer/init_lexer.c:		token->data = NULL;
srcs/LPA/lexer/init_lexer.c:	if (token->data)
srcs/LPA/lexer/init_lexer.c:		token->len = ft_strlen(token->data);
srcs/LPA/lexer/init_lexer.c:		token->len = 0;
srcs/LPA/lexer/io_nbr_nwl_token.c:/*   Updated: 2020/03/08 15:40:33 by mpivet-p         ###   ########.fr       */
srcs/LPA/lexer/io_nbr_nwl_token.c:	if (!lst || !lst->content)
srcs/LPA/lexer/io_nbr_nwl_token.c:	while (lst->next)
srcs/LPA/lexer/io_nbr_nwl_token.c:		lst = lst->next;
srcs/LPA/lexer/io_nbr_nwl_token.c:	id = ((t_token*)lst->content)->id;
srcs/LPA/lexer/io_nbr_nwl_token.c:	if ((lexer->buff[i] == '<' || lexer->buff[i] == '>')
srcs/LPA/lexer/io_nbr_nwl_token.c:		if (!(str = ft_strsub(lexer->buff, lexer->buf_pos, i - lexer->buf_pos)))
srcs/LPA/lexer/io_nbr_nwl_token.c:			fetch_token(&lexer->token, P_IONUMBER, str), sizeof(t_token)))))
srcs/LPA/lexer/io_nbr_nwl_token.c:		lexer->buf_pos = i;
srcs/LPA/lexer/io_nbr_nwl_token.c:		lexer->ntok++;
srcs/LPA/lexer/io_nbr_nwl_token.c:	i = lx->buf_pos;
srcs/LPA/lexer/io_nbr_nwl_token.c:	if (!lx->buff[lx->buf_pos] || !ft_isdigit(lx->buff[lx->buf_pos]))
srcs/LPA/lexer/io_nbr_nwl_token.c:		lx->status = L_END;
srcs/LPA/lexer/io_nbr_nwl_token.c:	while (ft_isdigit(lx->buff[i]) && lx->buff[i])
srcs/LPA/lexer/io_nbr_nwl_token.c:	lx->status = L_START;
srcs/LPA/lexer/io_nbr_nwl_token.c:	if (!lexer->buff[lexer->buf_pos])
srcs/LPA/lexer/io_nbr_nwl_token.c:		lexer->status = L_END;
srcs/LPA/lexer/io_nbr_nwl_token.c:	if (lexer->buff[lexer->buf_pos] == '\n')
srcs/LPA/lexer/io_nbr_nwl_token.c:		if (!(str = ft_strsub(lexer->buff, lexer->buf_pos, 1)))
srcs/LPA/lexer/io_nbr_nwl_token.c:			fetch_token(&lexer->token, P_NEWLINE, str), sizeof(t_token)))))
srcs/LPA/lexer/io_nbr_nwl_token.c:		lexer->ntok++;
srcs/LPA/lexer/io_nbr_nwl_token.c:		lexer->buf_pos++;
srcs/LPA/lexer/io_nbr_nwl_token.c:	lexer->status = L_START;
srcs/LPA/lexer/lexer.c:	if (!lx->buff)
srcs/LPA/lexer/lexer.c:		lx->status = L_END;
srcs/LPA/lexer/lexer.c:	if (lx->buff[lx->buf_pos] == ' ' || lx->buff[lx->buf_pos] == '\t')
srcs/LPA/lexer/lexer.c:		while (lx->buff[lx->buf_pos] == ' ' || lx->buff[lx->buf_pos] == '\t')
srcs/LPA/lexer/lexer.c:			lx->buf_pos++;
srcs/LPA/lexer/lexer.c:	lx->status = L_START;
srcs/LPA/lexer/lexer.c:	if (lx->buff[lx->buf_pos] == '\0')
srcs/LPA/lexer/lexer.c:	else if (tokens_discarder(lx->buff[lx->buf_pos]))
srcs/LPA/lexer/lexer.c:		lx->status = L_DISCARD;
srcs/LPA/lexer/lexer.c:	else if (lx->buff[lx->buf_pos] == '\n')
srcs/LPA/lexer/lexer.c:		lx->status = L_NEWLINE;
srcs/LPA/lexer/lexer.c:	else if (ft_strchr(OPERATORS, lx->buff[lx->buf_pos]))
srcs/LPA/lexer/lexer.c:		lx->status = L_OPERATOR;
srcs/LPA/lexer/lexer.c:	else if (ft_isdigit(lx->buff[lx->buf_pos]))
srcs/LPA/lexer/lexer.c:		lx->status = L_IO_NUMBER;
srcs/LPA/lexer/lexer.c:	else if (ft_strchr(&lx->buff[lx->buf_pos], '='))
srcs/LPA/lexer/lexer.c:		lx->status = L_ASSIGNEMENT_WORD;
srcs/LPA/lexer/lexer.c:		lx->status = L_NAME;
srcs/LPA/lexer/lexer.c:		fetch_token(&lexer->token, P_END, "newline"), sizeof(t_token)));
srcs/LPA/lexer/lexer.c:	lexer->ntok++;
srcs/LPA/lexer/lexer.c:	lexer->status = L_END;
srcs/LPA/lexer/name_token.c:/*   Updated: 2020/03/08 15:40:54 by mpivet-p         ###   ########.fr       */
srcs/LPA/lexer/name_token.c:		if ((index >= 1 && str[index - 1] != '\\')
srcs/LPA/lexer/name_token.c:	i = lexer->buf_pos;
srcs/LPA/lexer/name_token.c:	if (!(i = get_word_size_ntype(i, lexer->buff)))
srcs/LPA/lexer/name_token.c:	if (!(str = ft_strsub(lexer->buff, lexer->buf_pos, i - lexer->buf_pos)))
srcs/LPA/lexer/name_token.c:				fetch_token(&lexer->token, P_WORD, str), sizeof(t_token)));
srcs/LPA/lexer/name_token.c:	lexer->ntok++;
srcs/LPA/lexer/name_token.c:	lexer->buf_pos = i;
srcs/LPA/lexer/name_token.c:	if (!lexer->buff)
srcs/LPA/lexer/name_token.c:		lexer->status = L_END;
srcs/LPA/lexer/name_token.c:	lexer->status = L_START;
srcs/LPA/lexer/operator_token.c:/*   Updated: 2020/03/08 15:41:08 by mpivet-p         ###   ########.fr       */
srcs/LPA/lexer/operator_token.c:	{P_DLESSDASH, "<<-", 3},
srcs/LPA/lexer/operator_token.c:	if (!(str = ft_strsub(lx->buff, lx->buf_pos, len)))
srcs/LPA/lexer/operator_token.c:		fetch_token(&lx->token, id, str), sizeof(t_token)));
srcs/LPA/lexer/operator_token.c:	lx->ntok++;
srcs/LPA/lexer/operator_token.c:	lx->buf_pos += len;
srcs/LPA/lexer/operator_token.c:	lx->status = L_START;
srcs/LPA/lexer/operator_token.c:	if (!lx->buff)
srcs/LPA/lexer/operator_token.c:		lx->status = L_END;
srcs/LPA/lexer/operator_token.c:		if (!ft_strncmp(&lx->buff[lx->buf_pos], g_ope[i].data, g_ope[i].len))
srcs/LPA/lexer/operator_token.c:	lx->status = L_START;
srcs/LPA/lexer_parser_analyzer.c:/*   Updated: 2020/03/08 15:36:13 by mpivet-p         ###   ########.fr       */
srcs/LPA/lexer_parser_analyzer.c:		if (tmp->content)
srcs/LPA/lexer_parser_analyzer.c:			free_process_list(&((t_job*)tmp->content)->process_list);
srcs/LPA/lexer_parser_analyzer.c:			free(((t_job*)tmp->content)->command);
srcs/LPA/lexer_parser_analyzer.c:			free((t_job*)tmp->content);
srcs/LPA/lexer_parser_analyzer.c:		if (!tmp->next)
srcs/LPA/lexer_parser_analyzer.c:		tmp = tmp->next;
srcs/LPA/lexer_parser_analyzer.c:		if (tmp->content)
srcs/LPA/lexer_parser_analyzer.c:			ft_strdel(&((t_token*)tmp->content)->data);
srcs/LPA/lexer_parser_analyzer.c:			free(tmp->content);
srcs/LPA/lexer_parser_analyzer.c:		if (!tmp->next)
srcs/LPA/lexer_parser_analyzer.c:		tmp = tmp->next;
srcs/LPA/lexer_parser_analyzer.c:	lxr_tok = lexer(shell->term.buffer);
srcs/LPA/lexer_parser_analyzer.c:		shell->status = 2;
srcs/LPA/parser/parser.c:/*   Updated: 2020/03/08 15:41:27 by mpivet-p         ###   ########.fr       */
srcs/LPA/parser/parser.c:	init_start_graph(parser->graph);
srcs/LPA/parser/parser.c:	init_redirect_graph(parser->graph);
srcs/LPA/parser/parser.c:	init_process_graph(parser->graph);
srcs/LPA/parser/parser.c:	init_ionumber_graph(parser->graph);
srcs/LPA/parser/parser.c:	init_word_graph(parser->graph);
srcs/LPA/parser/parser.c:	parser->state = P_START;
srcs/LPA/parser/parser.c:		if (!(graph(&parser->state, ((t_token*)tok_lst->content)->id,
srcs/LPA/parser/parser.c:			parser->graph[parser->state].good_type)))
srcs/LPA/parser/parser.c:				((t_token*)tok_lst->content)->data);
srcs/LPA/parser/parser.c:		tok_lst = tok_lst->next;
srcs/builtins/bg.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/builtins/bg.c:/*   Created: 2019/12/04 15:59:13 by mpivet-p          #+#    #+#             */
srcs/builtins/bg.c:/*   Updated: 2020/03/08 14:25:40 by mpivet-p         ###   ########.fr       */
srcs/builtins/bg.c:	if (!(shell->is_interactive))
srcs/builtins/bg.c:	else if ((argc == 1 || (argc == 2 && ft_strcmp(argv[1], "--") == 0))
srcs/builtins/bg.c:		&& get_job(shell->launched_jobs, NULL) == NULL)
srcs/builtins/bg.c:	i = (process->av[1] && ft_strcmp(process->av[1], "--") == 0) ? 2 : 1;
srcs/builtins/bg.c:	if (can_bg_run(shell, process->av) != SUCCESS)
srcs/builtins/bg.c:	if (process->av[i] && process->av[i][0] == '-' && process->av[i][1] != 0)
srcs/builtins/bg.c:		, "42sh: bg: -%c: invalid option\nfb: usage: fb [jobspec]\n"
srcs/builtins/bg.c:		, process->av[i][1]);
srcs/builtins/bg.c:	while (process->av[i])
srcs/builtins/bg.c:		job = get_job(shell->launched_jobs, process->av[i]);
srcs/builtins/bg.c:			, (process->av[i]) ? process->av[1] : "current");
srcs/builtins/bg.c:		job->notified = FALSE;
srcs/builtins/cd/cd.c:/*   Created: 2019/12/03 16:22:47 by mpivet-p          #+#    #+#             */
srcs/builtins/cd/cd.c:/*   Updated: 2020/03/08 14:31:21 by mpivet-p         ###   ########.fr       */
srcs/builtins/cd/cd.c:	db_pwd = search_db(shell->env, "PWD");
srcs/builtins/cd/cd.c:	tmp = ft_strdup(db_oldpwd->value);
srcs/builtins/cd/cd.c:	tmp = ft_strjoinf(tmp, db_pwd->value, 1);
srcs/builtins/cd/cd.c:	ft_dprintf(STDOUT_FILENO, "%s\n", db_oldpwd->value);
srcs/builtins/cd/cd.c:	shell->cd.tmp_pwd = ft_strdup(db_oldpwd->value);
srcs/builtins/cd/cd.c:	shell->cd.dash = TRUE;
srcs/builtins/cd/cd.c:	if ((db_oldpwd = search_db(shell->env, "OLDPWD")) == NULL
srcs/builtins/cd/cd.c:		|| db_oldpwd->value == NULL)
srcs/builtins/cd/cd.c:	db_oldpwd->type = INTERNAL_VAR | EXPORT_VAR;
srcs/builtins/cd/cd.c:	if ((errnum = cd_check_path(db_oldpwd->value)) == SUCCESS
srcs/builtins/cd/cd.c:		&& shell->cd.pwd_error >= TRUE)
srcs/builtins/cd/cd.c:		ft_perror(db_oldpwd->value, "cd", errnum);
srcs/builtins/cd/cd.c:	ft_dprintf(STDOUT_FILENO, "%s\n", db_oldpwd->value);
srcs/builtins/cd/cd.c:	return (change_dir(shell, db_oldpwd->value));
srcs/builtins/cd/cd.c:	if (getcwd(pwd, MAX_PATH) == NULL && shell->cd.pwd_error == TRUE)
srcs/builtins/cd/cd.c:	if ((var = search_db(shell->env, "HOME")) == NULL)
srcs/builtins/cd/cd.c:	shell->cd.pwd_error = FALSE;
srcs/builtins/cd/cd.c:	if (chdir(var->value) != SUCCESS)
srcs/builtins/cd/cd.c:		ft_perror(var->value, "cd", cd_check_path(var->value));
srcs/builtins/cd/cd.c:	options = ft_get_options(ac, process->av, CD_OPT);
srcs/builtins/cd/cd.c:	if (!process->av[2] && options & ((1ULL << 37) | (1ULL << 41)))
srcs/builtins/cd/cd.c:		return (change_dir(shell, process->av[2]));
srcs/builtins/cd/cd.c:		if (process->av[2] && process->av[2][0] == '-' && !process->av[2][1])
srcs/builtins/cd/cd.c:			shell->cd.pwd_error = TRUE;
srcs/builtins/cd/cd.c:		shell->cd.no_symbolic = TRUE;
srcs/builtins/cd/cd.c:		return (change_dir(shell, process->av[2]));
srcs/builtins/cd/cd.c:	shell->cd.no_symbolic = FALSE;
srcs/builtins/cd/cd.c:	argc = ft_tablen(process->av);
srcs/builtins/cd/cd.c:	if (argc == 1 || ft_strcmp(process->av[1], "--") == 0)
srcs/builtins/cd/cd.c:	if (ft_strcmp(process->av[1], "-") == 0 && !process->av[1][1])
srcs/builtins/cd/cd.c:	if (process->av[1][0] == '-')
srcs/builtins/cd/cd.c:	change_dir(shell, process->av[1]);
srcs/builtins/cd/cd_change_dir.c:/*   Updated: 2020/03/08 14:29:25 by mpivet-p         ###   ########.fr       */
srcs/builtins/cd/cd_change_dir.c:	if (shell->cd.pwd_error == TRUE)
srcs/builtins/cd/cd_change_dir.c:	if (shell->cd.pwd_error == TRUE)
srcs/builtins/cd/cd_change_dir.c:		if (shell->cd.no_symbolic == TRUE && errnum != EACCES)
srcs/builtins/cd/cd_change_dir.c:		if (shell->cd.error > 0)
srcs/builtins/cd/cd_change_dir.c:			shell->cd.error = shell->cd.error - 1;
srcs/builtins/cd/cd_change_dir.c:			shell->cd.no_symbolic == TRUE ? "PWD" : "OLDPWD",
srcs/builtins/cd/cd_change_dir.c:	ft_strcpy(pwd, db->value);
srcs/builtins/cd/cd_change_dir.c:	errnum = cd_check_path(buffer[0] == '\0' ? db->value : buffer);
srcs/builtins/cd/cd_change_dir.c:	if (cd_check_path(db->value) == EACCES)
srcs/builtins/cd/cd_change_dir.c:	else if (shell->cd.pwd_error == TRUE
srcs/builtins/cd/cd_change_dir.c:			&& ft_strlen(pwd) < 1 && cd_check_path(db->value) != EACCES)
srcs/builtins/cd/cd_check_path.c:/*   Updated: 2020/03/08 14:30:48 by mpivet-p         ###   ########.fr       */
srcs/builtins/cd/cd_check_path.c:	if ((process->av[1][0] != '-' && ac > 2)
srcs/builtins/cd/cd_check_path.c:		|| (process->av[1][0] == '-' && ac > 3))
srcs/builtins/cd/cd_update_pwd.c:/*   Updated: 2020/03/08 14:30:57 by mpivet-p         ###   ########.fr       */
srcs/builtins/cd/cd_update_pwd.c:	if (shell->cd.no_symbolic == TRUE)
srcs/builtins/cd/cd_update_pwd.c:	else if (db_oldpwd->value && db_oldpwd->value[0] == '/')
srcs/builtins/cd/cd_update_pwd.c:		if (ft_strequ(db_oldpwd->value, ".") == TRUE)
srcs/builtins/cd/cd_update_pwd.c:			value = ft_strdup(db_oldpwd->value);
srcs/builtins/cd/cd_update_pwd.c:			value = ft_strjoinf(value, shell->cd.dash == TRUE
srcs/builtins/cd/cd_update_pwd.c:										? shell->cd.tmp_pwd : (char *)path, 1);
srcs/builtins/cd/cd_update_pwd.c:			ft_strdel(&shell->cd.tmp_pwd);
srcs/builtins/cd/cd_update_pwd.c:	if (shell->cd.pwd_error == TRUE && shell->cd.no_symbolic == FALSE)
srcs/builtins/cd/cd_update_pwd.c:		shell->cd.error = error;
srcs/builtins/cd/cd_update_pwd.c:		if (shell->cd.pwd_error >= TRUE)
srcs/builtins/cd/cd_update_pwd.c:		else if (shell->cd.no_symbolic == TRUE || !(S_ISLNK(db_stat.st_mode)))
srcs/builtins/cd/cd_use_cd_path.c:/*   Updated: 2020/03/08 14:31:06 by mpivet-p         ###   ########.fr       */
srcs/builtins/cd/cd_use_cd_path.c:		if ((pwd = search_db(shell->env, "PWD")) == NULL)
srcs/builtins/cd/cd_use_cd_path.c:		dir = ft_strdup(pwd->value);
srcs/builtins/cd/cd_use_cd_path.c:		&& shell && (cdpath = search_db(shell->env, "CDPATH")) != NULL)
srcs/builtins/cd/cd_use_cd_path.c:		tab = ft_strsplit(cdpath->value, ":");
srcs/builtins/echo.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/builtins/echo.c:/*   Created: 2019/12/04 15:59:13 by mpivet-p          #+#    #+#             */
srcs/builtins/echo.c:/*   Updated: 2020/03/08 14:26:02 by mpivet-p         ###   ########.fr       */
srcs/builtins/echo.c:	argc = ft_tablen(process->av);
srcs/builtins/echo.c:		if (write(STDOUT_FILENO, process->av[i], ft_strlen(process->av[i])) < 0)
srcs/builtins/exit.c:/*   Created: 2019/11/25 23:42:04 by mpivet-p          #+#    #+#             */
srcs/builtins/exit.c:/*   Updated: 2020/03/08 14:26:12 by mpivet-p         ###   ########.fr       */
srcs/builtins/exit.c:	argc = ft_tablen(process->av);
srcs/builtins/exit.c:	if (are_jobs_done(shell, shell->launched_jobs) != TRUE)
srcs/builtins/exit.c:		return (shell->status);
srcs/builtins/exit.c:		quit_shell(shell, shell->status, 1);
srcs/builtins/exit.c:	if (ft_atol(process->av[1], &exit_value) != SUCCESS)
srcs/builtins/exit.c:		, "exit\n42sh: exit: %s: numeric argument required\n", process->av[1]);
srcs/builtins/export.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/builtins/export.c:/*   Created: 2019/09/30 03:30:02 by mpivet-p          #+#    #+#             */
srcs/builtins/export.c:/*   Updated: 2020/03/08 14:26:21 by mpivet-p         ###   ########.fr       */
srcs/builtins/export.c:		free_hash_map(&shell->hash);
srcs/builtins/export.c:		modify_db(db, str, db->type | EXPORT_VAR | INTERNAL_VAR);
srcs/builtins/export.c:		modify_db(db, str, db->type | EXPORT_VAR);
srcs/builtins/export.c:	db = shell->env;
srcs/builtins/export.c:		ptr = ((t_db*)db->content);
srcs/builtins/export.c:		if (ptr->type & EXPORT_VAR)
srcs/builtins/export.c:			if (ptr->value)
srcs/builtins/export.c:				ft_printf("export %s=\"%s\"\n", ptr->key, ptr->value);
srcs/builtins/export.c:				ft_printf("export %s\n", ptr->key);
srcs/builtins/export.c:		db = db->next;
srcs/builtins/export.c:	while (process->envp[i])
srcs/builtins/export.c:		str = process->envp[i];
srcs/builtins/export.c:		value = ft_strsub(str, len + 1, ft_strlen(str) - len);
srcs/builtins/export.c:	argc = ft_tablen(process->av);
srcs/builtins/export.c:	i = (argc > 1 && process->av[1][0] != '-') ? 1 : 2;
srcs/builtins/export.c:	if ((ret = parse_export(argc, process->av, &opt)) != SUCCESS)
srcs/builtins/export.c:		if (export(shell, process->av[i], &ret, opt) != SUCCESS)
srcs/builtins/fc/fc.c:/*   Updated: 2020/03/08 14:32:23 by mpivet-p         ###   ########.fr       */
srcs/builtins/fc/fc.c:"fc: usage: fc [-e ename] [-lnr] [first] [last] or fc -s [pat=rep] [command]");
srcs/builtins/fc/fc.c:		ft_dprintf(2, "42sh: fc: -e: option requires an argument\n");
srcs/builtins/fc/fc.c:		ft_dprintf(STDERR_FILENO, "fc: usage: fc [-e ename] \
srcs/builtins/fc/fc.c:			[-lnr] [first] [last] or fc -s [pat=rep] [command]\n");
srcs/builtins/fc/fc.c:			if (ft_strequ(*av, "-e") && *(av + 1) == NULL)
srcs/builtins/fc/fc.c:**	Editing (default) & Listing (-lnr options)
srcs/builtins/fc/fc.c:	if ((w = shell->term.history) == NULL)
srcs/builtins/fc/fc.c:	opt = ft_get_options(ft_tablen(process->av), process->av, FC_OPT);
srcs/builtins/fc/fc.c:	if (fc_options(process->av, opt) == FALSE)
srcs/builtins/fc/fc.c:		return (select_specifier(shell, process->av));
srcs/builtins/fc/fc.c:		listing_mode(w, process->av, opt);
srcs/builtins/fc/fc_edit.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/builtins/fc/fc_edit.c:/*   Updated: 2020/03/11 18:58:14 by mpivet-p         ###   ########.fr       */
srcs/builtins/fc/fc_edit.c:	while (ft_getnextline(cmd.fd, &shell->term.buffer) > 0)
srcs/builtins/fc/fc_edit.c:		do_job_notification(shell, shell->launched_jobs, TRUE);
srcs/builtins/fc/fc_edit.c:		save_history(&shell->term);
srcs/builtins/fc/fc_edit.c:		ft_strdel(&shell->term.buffer);
srcs/builtins/fc/fc_edit.c:	ft_strdel(&shell->term.buffer);
srcs/builtins/fc/fc_edit.c:	shell->term.buffer = ft_memalloc(BUFF_SIZE);
srcs/builtins/fc/fc_edit.c:									S_IRUSR | S_IRGRP | S_IROTH)) == -1)
srcs/builtins/fc/fc_edit.c:	ft_strdel(&shell->term.buffer);
srcs/builtins/fc/fc_edit.c:	if (!shell->term.history)
srcs/builtins/fc/fc_edit.c:	get_range(process->av, &cmd);
srcs/builtins/fc/fc_edit.c:	get_entries(shell->term.history, &cmd, opt);
srcs/builtins/fc/fc_edit.c:	sort_print_cmd(cmd, shell->term.history, opt);
srcs/builtins/fc/fc_edit.c:	cmd.editor = get_editor(process->av, opt);
srcs/builtins/fc/fc_launcher.c:/*   Updated: 2020/03/08 14:31:55 by mpivet-p         ###   ########.fr       */
srcs/builtins/fc/fc_launcher.c:	free_process_list(&(((t_job*)(*job)->content)->process_list));
srcs/builtins/fc/fc_launcher.c:	free((*job)->content);
srcs/builtins/fc/fc_launcher.c:	(*job)->content = NULL;
srcs/builtins/fc/fc_launcher.c:	process->av = argv;
srcs/builtins/fc/fc_launcher.c:	process->envp = set_envp(shell);
srcs/builtins/fc/fc_launcher.c:	process->pipe[0] = STDIN_FILENO;
srcs/builtins/fc/fc_launcher.c:	process->pipe[1] = STDOUT_FILENO;
srcs/builtins/fc/fc_launcher.c:	process->close[0] = -1;
srcs/builtins/fc/fc_launcher.c:	process->close[1] = -1;
srcs/builtins/fc/fc_launcher.c:	ptr = shell->job_list;
srcs/builtins/fc/fc_launcher.c:	job_ptr->next = ptr;
srcs/builtins/fc/fc_launcher.c:	shell->job_list = job_ptr;
srcs/builtins/fc/fc_launcher.c:	exec_process(shell, job_ptr->content, job.process_list->content);
srcs/builtins/fc/fc_launcher.c:	shell->job_list = ptr;
srcs/builtins/fc/fc_launcher.c:	job_ptr->next = NULL;
srcs/builtins/fc/fc_launcher.c:	if (job_is_completed(job_ptr->content))
srcs/builtins/fc/fc_launcher.c:		ft_lstappend(&(shell->launched_jobs), job_ptr);
srcs/builtins/fc/fc_listing.c:/*   Updated: 2020/03/08 14:32:02 by mpivet-p         ###   ########.fr       */
srcs/builtins/fc/fc_listing.c:	if (cmd->first <= 0 && (opt & (1ULL << 4)))
srcs/builtins/fc/fc_listing.c:		cmd->first = w_entries;
srcs/builtins/fc/fc_listing.c:	else if (cmd->first <= 0)
srcs/builtins/fc/fc_listing.c:		cmd->first = w_entries + cmd->first + 1;
srcs/builtins/fc/fc_listing.c:	if (cmd->last <= 0 && (opt & (1ULL << 4)))
srcs/builtins/fc/fc_listing.c:		cmd->last = cmd->first;
srcs/builtins/fc/fc_listing.c:	else if (cmd->last <= 0)
srcs/builtins/fc/fc_listing.c:		cmd->last = w_entries + cmd->last + 1;
srcs/builtins/fc/fc_listing.c:	if (cmd->ac == 2)
srcs/builtins/fc/fc_listing.c:		cmd->first = w_entries - 15;
srcs/builtins/fc/fc_listing.c:		cmd->last = w_entries;
srcs/builtins/fc/fc_listing.c:		if (ft_isstart(**av, "-l") || ft_isstart(**av, "-r")
srcs/builtins/fc/fc_listing.c:				|| ft_isstart(**av, "-n") || ft_isstart(**av, "-s")
srcs/builtins/fc/fc_listing.c:				|| ft_isstart(**av, "-e"))
srcs/builtins/fc/fc_listing.c:	(*av)--;
srcs/builtins/fc/fc_listing.c:	if ((cmd->ac = ft_tablen(av)) == 2)
srcs/builtins/fc/fc_listing.c:	if (ft_tabchr(av, "-e"))
srcs/builtins/fc/fc_listing.c:			cmd->first = ft_atoi(*av);
srcs/builtins/fc/fc_listing.c:		cmd->last = ft_atoi(*(av + 1));
srcs/builtins/fc/fc_print.c:			ft_dprintf(cmd.fd, "\t%s\n", w->content);
srcs/builtins/fc/fc_print.c:			ft_dprintf(cmd.fd, "%s\n", w->content);
srcs/builtins/fc/fc_print.c:			ft_dprintf(cmd.fd, "%d\t%s\n", i, w->content);
srcs/builtins/fc/fc_print.c:		w = w->next;
srcs/builtins/fc/fc_print.c:		i--;
srcs/builtins/fc/fc_print.c:	while (w->next)
srcs/builtins/fc/fc_print.c:		w = w->next;
srcs/builtins/fc/fc_print.c:			ft_dprintf(cmd.fd, "\t%s\n", w->content);
srcs/builtins/fc/fc_print.c:			ft_dprintf(cmd.fd, "%s\n", w->content);
srcs/builtins/fc/fc_print.c:			ft_dprintf(cmd.fd, "%d\t%s\n", i, w->content);
srcs/builtins/fc/fc_print.c:		w = w->prev;
srcs/builtins/fc/fc_specifier.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/builtins/fc/fc_specifier.c:/*   Updated: 2020/03/11 18:58:22 by mpivet-p         ###   ########.fr       */
srcs/builtins/fc/fc_specifier.c:	if ((pat_index = ft_strstr(shell->term.buffer, pat)) == NULL)
srcs/builtins/fc/fc_specifier.c:	tmp = ft_strdup(shell->term.buffer);
srcs/builtins/fc/fc_specifier.c:	replace = ft_strsub(tmp, 0, pat_index - shell->term.buffer);
srcs/builtins/fc/fc_specifier.c:	ft_strdel(&shell->term.buffer);
srcs/builtins/fc/fc_specifier.c:	shell->term.buffer = ft_strdup(replace);
srcs/builtins/fc/fc_specifier.c:	w = shell->term.history;
srcs/builtins/fc/fc_specifier.c:		if (cmd == (int)w->content_size)
srcs/builtins/fc/fc_specifier.c:			ft_strdel(&shell->term.buffer);
srcs/builtins/fc/fc_specifier.c:			shell->term.buffer = ft_strdup(w->content);
srcs/builtins/fc/fc_specifier.c:		w = w->next;
srcs/builtins/fc/fc_specifier.c:	w_entries = ft_lstlen(shell->term.history);
srcs/builtins/fc/fc_specifier.c:		if ((cmd * (-1)) > w_entries)
srcs/builtins/fc/fc_specifier.c:**			[fc -s [old=new] [specifier]]
srcs/builtins/fc/fc_specifier.c:**		=> select specifier in history to re-enter
srcs/builtins/fc/fc_specifier.c:	if (shell->term.history == NULL)
srcs/builtins/fc/fc_specifier.c:	ft_strdel(&shell->term.buffer);
srcs/builtins/fc/fc_specifier.c:	shell->term.buffer = ft_strdup(shell->term.history->content);
srcs/builtins/fc/fc_specifier.c:	ft_dprintf(cmd.fd, "%s\n", shell->term.buffer);
srcs/builtins/fc/fc_specifier.c:	do_job_notification(shell, shell->launched_jobs, TRUE);
srcs/builtins/fg.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/builtins/fg.c:/*   Created: 2019/12/04 15:59:13 by mpivet-p          #+#    #+#             */
srcs/builtins/fg.c:/*   Updated: 2020/03/08 14:26:30 by mpivet-p         ###   ########.fr       */
srcs/builtins/fg.c:	i = (process->av[1] && ft_strcmp(process->av[1], "--") == 0) ? 2 : 1;
srcs/builtins/fg.c:	if (!(shell->is_interactive))
srcs/builtins/fg.c:	if (process->av[i] && process->av[i][0] == '-' && process->av[i][1] != 0)
srcs/builtins/fg.c:		, "42sh: fg: -%c: invalid option\nfg: usage: fg [jobspec]\n"
srcs/builtins/fg.c:		, process->av[i][1]);
srcs/builtins/fg.c:	job = get_job(shell->launched_jobs, process->av[i]);
srcs/builtins/fg.c:		, (process->av[i]) ? process->av[i] : "current");
srcs/builtins/fg.c:	ft_printf("%s\n", job->command);
srcs/builtins/hash/add_hash_map.c:/*   Updated: 2020/03/08 14:32:56 by mpivet-p         ###   ########.fr       */
srcs/builtins/hash/add_hash_map.c:	shell->hash.lenght++;
srcs/builtins/hash/add_hash_map.c:	load_factor = (float)shell->hash.lenght / shell->hash.size;
srcs/builtins/hash/add_hash_map.c:	shell->hash.value = get_hash(key, shell->hash.size);
srcs/builtins/hash/add_hash_map.c:	if (!(ft_lstappend(&shell->hash.map[shell->hash.value],
srcs/builtins/hash/add_hash_map.c:		ft_lstnew(fetch_hash_db(&shell->db, key, value, fmt),
srcs/builtins/hash/add_hash_map.c:	hash = get_hash(process->av[i], shell->hash.size);
srcs/builtins/hash/add_hash_map.c:	map = shell->hash.map[hash];
srcs/builtins/hash/add_hash_map.c:		if (ft_strequ(process->av[i], ((t_db*)map->content)->key) == TRUE)
srcs/builtins/hash/add_hash_map.c:			ft_strdel(&(((t_db*)map->content)->value));
srcs/builtins/hash/add_hash_map.c:			if (!(((t_db*)map->content)->value = ft_strdup(process->av[2])))
srcs/builtins/hash/add_hash_map.c:			((t_db*)map->content)->hit = 0;
srcs/builtins/hash/add_hash_map.c:		map = map->next;
srcs/builtins/hash/add_hash_map.c:		&& fill_exec(shell, process->av[i], process->av[2], fmt) != SUCCESS)
srcs/builtins/hash/add_hash_map.c:	if (ft_strchr(process->av[i], '/'))
srcs/builtins/hash/add_hash_map.c:	shell->hash.value = get_hash(process->av[i], shell->hash.size);
srcs/builtins/hash/add_hash_map.c:	sub_map = shell->hash.map[shell->hash.value];
srcs/builtins/hash/add_hash_map.c:		if (ft_strequ(process->av[i], ((t_db*)sub_map->content)->key))
srcs/builtins/hash/add_hash_map.c:			((t_db*)sub_map->content)->hit = 0;
srcs/builtins/hash/add_hash_map.c:		sub_map = sub_map->next;
srcs/builtins/hash/add_hash_map.c:	if ((is_a_blt(process->av[i]) != FAILURE)
srcs/builtins/hash/add_hash_map.c:	process_tmp.av[0] = ft_strdup(process->av[i]);
srcs/builtins/hash/add_hash_map.c:			process->av[i]);
srcs/builtins/hash/add_hash_map.c:	if (fmt == H_EXEC && process->bin == NULL)
srcs/builtins/hash/add_hash_map.c:	if (shell->hash.map == NULL
srcs/builtins/hash/add_hash_map.c:		&& !(shell->hash.map = ft_memalloc(sizeof(t_lst*) * shell->hash.size)))
srcs/builtins/hash/add_hash_map.c:		return (hash_error(&shell->hash));
srcs/builtins/hash/add_hash_map.c:		if (fill_fp[fmt](shell, process->av[0], process->bin, fmt) != SUCCESS)
srcs/builtins/hash/add_hash_map.c:			return (hash_error(&shell->hash));
srcs/builtins/hash/add_hash_map.c:		while (process->av[i])
srcs/builtins/hash/add_hash_map.c:				return (hash_error(&shell->hash));
srcs/builtins/hash/add_hash_map.c:	if (shell->hash.lenght == 0)
srcs/builtins/hash/add_hash_map.c:		reset_hash(&shell->hash);
srcs/builtins/hash/fetch_hash_db.c:	if (!(db->key = ft_strdup(key)))
srcs/builtins/hash/fetch_hash_db.c:	if (!(db->value = ft_strdup(value)))
srcs/builtins/hash/fetch_hash_db.c:		db->hit = 1;
srcs/builtins/hash/fetch_hash_db.c:		db->hit = 0;
srcs/builtins/hash/hash.c:	options = ft_get_options(ac, process->av, HASH_OPT);
srcs/builtins/hash/hash.c:		if (options & (1ULL << (HASH_OPT[i] - 97)))
srcs/builtins/hash/hash.c:	ac = ft_tablen(process->av);
srcs/builtins/hash/hash.c:	if (ac > 1 && process->av[1][0] != '-')
srcs/builtins/hash/hash_handler.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/builtins/hash/hash_handler.c:/*   Updated: 2020/03/08 14:36:36 by mpivet-p         ###   ########.fr       */
srcs/builtins/hash/hash_handler.c:	free(hash->map);
srcs/builtins/hash/hash_handler.c:	hash->map = NULL;
srcs/builtins/hash/hash_handler.c:	hash->lenght = 0;
srcs/builtins/hash/hash_handler.c:	hash->size = HASH_SIZE;
srcs/builtins/hash/hash_handler.c:	if (!hash || !hash->map)
srcs/builtins/hash/hash_handler.c:	while (i < hash->size)
srcs/builtins/hash/hash_handler.c:		if (ft_lstlen(hash->map[i]) > 0)
srcs/builtins/hash/hash_handler.c:			while (hash->map[i])
srcs/builtins/hash/hash_handler.c:				ft_strdel(&((t_db*)(hash->map[i]->content))->key);
srcs/builtins/hash/hash_handler.c:				ft_strdel(&((t_db*)(hash->map[i]->content))->value);
srcs/builtins/hash/hash_handler.c:				free(hash->map[i]->content);
srcs/builtins/hash/hash_handler.c:				tmp = hash->map[i];
srcs/builtins/hash/hash_handler.c:				hash->map[i] = hash->map[i]->next;
srcs/builtins/hash/hash_handler.c:	ft_strdel(&((t_db *)map->content)->key);
srcs/builtins/hash/hash_handler.c:	ft_strdel(&((t_db *)map->content)->value);
srcs/builtins/hash/hash_handler.c:	free(map->content);
srcs/builtins/hash/hash_handler.c:	hash->lenght--;
srcs/builtins/hash/hash_handler.c:	if (hash->lenght == 0)
srcs/builtins/hash/hash_opt.c:/*   Updated: 2020/03/08 14:37:25 by mpivet-p         ###   ########.fr       */
srcs/builtins/hash/hash_opt.c:	free_hash_map(&shell->hash);
srcs/builtins/hash/hash_opt.c:			"42sh: hash: -p: option requires an argument\n");
srcs/builtins/hash/hash_opt.c:		print_usage("hash", 0, "[-rl] [-p pathname] [-dt] [name ...]");
srcs/builtins/hash/hash_opt.c:	if (is_a_dir(process->av[2]) == EISDIR)
srcs/builtins/hash/hash_opt.c:		while (process->av[i])
srcs/builtins/hash/hash_opt.c:					process->av[2]);
srcs/builtins/hash/hash_opt.c:	while (process->av[i])
srcs/builtins/hash/hash_opt.c:		hash_key_remover(shell, process->av[i++]);
srcs/builtins/hash/hash_opt.c:			"42sh: hash: -t: option requires an argument\n");
srcs/builtins/hash/hash_opt_tools.c:/*   Updated: 2020/03/08 14:37:15 by mpivet-p         ###   ########.fr       */
srcs/builtins/hash/hash_opt_tools.c:	i = -1;
srcs/builtins/hash/hash_opt_tools.c:	if ((map = shell->hash.map) == NULL)
srcs/builtins/hash/hash_opt_tools.c:	while (++i < shell->hash.size)
srcs/builtins/hash/hash_opt_tools.c:						((t_db *)cur_map->content)->hit,
srcs/builtins/hash/hash_opt_tools.c:						((t_db *)cur_map->content)->value);
srcs/builtins/hash/hash_opt_tools.c:				ft_dprintf(STDOUT_FILENO, "builtin hash -p %s %s\n",
srcs/builtins/hash/hash_opt_tools.c:						((t_db *)cur_map->content)->value,
srcs/builtins/hash/hash_opt_tools.c:						((t_db *)cur_map->content)->key);
srcs/builtins/hash/hash_opt_tools.c:			cur_map = cur_map->next;
srcs/builtins/hash/hash_opt_tools.c:	if (shell->hash.map == NULL || process == NULL)
srcs/builtins/hash/hash_opt_tools.c:	hash_value = get_hash(process, shell->hash.size);
srcs/builtins/hash/hash_opt_tools.c:	map = shell->hash.map[hash_value];
srcs/builtins/hash/hash_opt_tools.c:	if (map && ft_strequ(((t_db *)map->content)->key, process) == TRUE)
srcs/builtins/hash/hash_opt_tools.c:		shell->hash.map[hash_value] = map->next;
srcs/builtins/hash/hash_opt_tools.c:		return (free_hash_key(&shell->hash, map));
srcs/builtins/hash/hash_opt_tools.c:	while (map && ft_strequ(((t_db *)map->content)->key, process) == FALSE)
srcs/builtins/hash/hash_opt_tools.c:		if ((map = map->next) == NULL)
srcs/builtins/hash/hash_opt_tools.c:	prev->next = map->next;
srcs/builtins/hash/hash_opt_tools.c:	free_hash_key(&shell->hash, map);
srcs/builtins/hash/hash_opt_tools.c:		if (ft_strequ(process->av[i], ((t_db *)sub_map->content)->key))
srcs/builtins/hash/hash_opt_tools.c:				ft_dprintf(STDOUT_FILENO, "%-*s%s\n",
srcs/builtins/hash/hash_opt_tools.c:						get_hash_t_pad(((t_db *)sub_map->content)->key),
srcs/builtins/hash/hash_opt_tools.c:						((t_db *)sub_map->content)->key,
srcs/builtins/hash/hash_opt_tools.c:						((t_db *)sub_map->content)->value);
srcs/builtins/hash/hash_opt_tools.c:						((t_db *)sub_map->content)->value);
srcs/builtins/hash/hash_opt_tools.c:			((t_db *)sub_map->content)->hit += 1;
srcs/builtins/hash/hash_opt_tools.c:		sub_map = sub_map->next;
srcs/builtins/hash/hash_opt_tools.c:				"42sh: hash: %s: not found\n", process->av[i]);
srcs/builtins/hash/hash_opt_tools.c:	if (shell->hash.map)
srcs/builtins/hash/hash_opt_tools.c:		map = shell->hash.map;
srcs/builtins/hash/hash_opt_tools.c:	while (process->av[i])
srcs/builtins/hash/hash_opt_tools.c:		shell->hash.value = get_hash(process->av[i], shell->hash.size);
srcs/builtins/hash/hash_opt_tools.c:		if (map == NULL || map[shell->hash.value] == NULL)
srcs/builtins/hash/hash_opt_tools.c:					"42sh: hash: %s: not found\n", process->av[i]);
srcs/builtins/hash/hash_opt_tools.c:		find_hash_sub_map(process, map[shell->hash.value], i, ac);
srcs/builtins/hash/locate_hash.c:/*   Updated: 2020/03/08 14:37:36 by mpivet-p         ###   ########.fr       */
srcs/builtins/hash/locate_hash.c:	if (((t_db*)node->content)->value[0] == '.'
srcs/builtins/hash/locate_hash.c:		&& ((t_db*)node->content)->value[1] == '/'
srcs/builtins/hash/locate_hash.c:		&& ((t_db*)node->content)->value[2] != 0)
srcs/builtins/hash/locate_hash.c:		((t_db*)node->content)->hit += 1;
srcs/builtins/hash/locate_hash.c:		hash_key_remover(shell, process->av[0]);
srcs/builtins/hash/locate_hash.c:	process->bin = NULL;
srcs/builtins/hash/locate_hash.c:	shell->hash.value = get_hash(process->av[0], shell->hash.size);
srcs/builtins/hash/locate_hash.c:	if (shell->hash.map == NULL || shell->hash.map[shell->hash.value] == NULL)
srcs/builtins/hash/locate_hash.c:	sub_map = shell->hash.map[shell->hash.value];
srcs/builtins/hash/locate_hash.c:		if (ft_strequ(process->av[0], ((t_db*)sub_map->content)->key))
srcs/builtins/hash/locate_hash.c:			if (ft_access(((t_db*)sub_map->content)->value,
srcs/builtins/hash/locate_hash.c:			process->bin = ft_strdup(((t_db*)sub_map->content)->value);
srcs/builtins/hash/locate_hash.c:			((t_db*)sub_map->content)->hit += 1;
srcs/builtins/hash/locate_hash.c:		sub_map = sub_map->next;
srcs/builtins/hash/resize_hash_map.c:	while (i < shell->hash.size)
srcs/builtins/hash/resize_hash_map.c:			shell->hash.value = get_hash(((t_db*)(sub_map->content))->key,
srcs/builtins/hash/resize_hash_map.c:									(shell->hash.size * 2));
srcs/builtins/hash/resize_hash_map.c:			if (!(ft_lstappend(&new_map[shell->hash.value],
srcs/builtins/hash/resize_hash_map.c:					ft_lstnew(fetch_hash_db(&shell->db,
srcs/builtins/hash/resize_hash_map.c:					((t_db*)(sub_map->content))->key,
srcs/builtins/hash/resize_hash_map.c:					((t_db*)(sub_map->content))->value,
srcs/builtins/hash/resize_hash_map.c:					((t_db*)(sub_map->content))->hit), sizeof(t_db)))))
srcs/builtins/hash/resize_hash_map.c:			sub_map = sub_map->next;
srcs/builtins/hash/resize_hash_map.c:	map = shell->hash.map;
srcs/builtins/hash/resize_hash_map.c:	tmp_hash_lenght = shell->hash.lenght;
srcs/builtins/hash/resize_hash_map.c:	tmp_hash_size = shell->hash.size;
srcs/builtins/hash/resize_hash_map.c:	if (!(new_map = ft_memalloc(sizeof(t_lst*) * (shell->hash.size * 2))))
srcs/builtins/hash/resize_hash_map.c:	free_hash_map(&(shell->hash));
srcs/builtins/hash/resize_hash_map.c:	shell->hash.map = new_map;
srcs/builtins/hash/resize_hash_map.c:	shell->hash.size = tmp_hash_size * 2;
srcs/builtins/hash/resize_hash_map.c:	shell->hash.lenght = tmp_hash_lenght;
srcs/builtins/jobs.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/builtins/jobs.c:/*   Created: 2019/12/03 16:22:47 by mpivet-p          #+#    #+#             */
srcs/builtins/jobs.c:/*   Updated: 2020/03/10 19:31:45 by mpivet-p         ###   ########.fr       */
srcs/builtins/jobs.c:	ptr = job->process_list;
srcs/builtins/jobs.c:		process = ((t_process *)ptr->content);
srcs/builtins/jobs.c:		if (ptr == job->process_list)
srcs/builtins/jobs.c:			ft_printf("[%d]%c %d %-24s %s\n", job->jobc_id, job->jobc_last
srcs/builtins/jobs.c:			, process->pid, signal_msg(process->status), process->command);
srcs/builtins/jobs.c:			ft_printf("     %d %24s%s\n", process->pid
srcs/builtins/jobs.c:			, signal_msg(process->status), process->command);
srcs/builtins/jobs.c:		ptr = ptr->next;
srcs/builtins/jobs.c:		ft_printf("%d\n", job->pgid);
srcs/builtins/jobs.c:		ft_printf("[%d]%c  %s\t\t%s\n", job->jobc_id, job->jobc_last
srcs/builtins/jobs.c:		, (job_is_stopped(job)) ? "Stopped" : "Done", job->command);
srcs/builtins/jobs.c:	argc = ft_tablen(process->av);
srcs/builtins/jobs.c:	job_list = shell->launched_jobs;
srcs/builtins/jobs.c:	i = skip_opt(process->av);
srcs/builtins/jobs.c:	if (shell->launched_jobs)
srcs/builtins/jobs.c:	if ((opt = ft_get_options(argc, process->av, "lp")) & (1ULL << 63))
srcs/builtins/jobs.c:		print_usage("42sh: jobs", opt & 0xFF, "jobs [-lp] [jobspec ...]");
srcs/builtins/jobs.c:		print_job(job_list->content, opt, NULL);
srcs/builtins/jobs.c:		job_list = job_list->next;
srcs/builtins/jobs.c:		job = get_job(shell->launched_jobs, process->av[i]);
srcs/builtins/jobs.c:		print_job(job, opt, process->av[i++]);
srcs/builtins/path_tests.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/builtins/path_tests.c:/*   Created: 2020/01/30 20:12:52 by mpivet-p          #+#    #+#             */
srcs/builtins/path_tests.c:/*   Updated: 2020/03/08 14:27:02 by mpivet-p         ###   ########.fr       */
srcs/builtins/pwd.c:/*   Created: 2019/12/05 16:51:46 by mpivet-p          #+#    #+#             */
srcs/builtins/pwd.c:/*   Updated: 2020/03/08 14:27:13 by mpivet-p         ###   ########.fr       */
srcs/builtins/pwd.c:	options = ft_get_options(ac, process->av, "LP");
srcs/builtins/pwd.c:		ft_dprintf(STDOUT_FILENO, "%s\n", db->value);
srcs/builtins/pwd.c:	ac = ft_tablen(process->av);
srcs/builtins/pwd.c:	lstat(db->value, &stat);
srcs/builtins/pwd.c:		&& (errnum = pwd_check_path(db->value)) != SUCCESS)
srcs/builtins/pwd.c:		shell->cd.pwd_error = TRUE;
srcs/builtins/pwd.c:	ft_dprintf(STDOUT_FILENO, "%s\n", db->value);
srcs/builtins/set.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/builtins/set.c:/*   Created: 2019/09/28 22:37:53 by mpivet-p          #+#    #+#             */
srcs/builtins/set.c:/*   Updated: 2020/03/08 14:27:21 by mpivet-p         ###   ########.fr       */
srcs/builtins/set.c:	ptr = shell->env;
srcs/builtins/set.c:		if (((t_db*)ptr->content)->type & INTERNAL_VAR)
srcs/builtins/set.c:			ft_dprintf(STDOUT_FILENO, "%s=%s\n", ((t_db*)ptr->content)->key
srcs/builtins/set.c:					, ((t_db*)ptr->content)->value);
srcs/builtins/set.c:		ptr = ptr->next;
srcs/builtins/set.c:	shell->db.key = ft_itoa(count);
srcs/builtins/set.c:	shell->db.value = ft_strdup(arg);
srcs/builtins/set.c:	shell->db.type = SPECIAL_VAR;
srcs/builtins/set.c:	if (!shell->db.key || !shell->db.value || ft_lstappend(&shell->pos_vars
srcs/builtins/set.c:				, ft_lstnew(&shell->db, sizeof(t_db))) == NULL)
srcs/builtins/set.c:		ft_strdel(&(shell->db.key));
srcs/builtins/set.c:		ft_strdel(&(shell->db.value));
srcs/builtins/set.c:	i = (process->av[1][0] != '-') ? 1 : 2;
srcs/builtins/set.c:	free_db(shell->pos_vars);
srcs/builtins/set.c:	shell->pos_vars = NULL;
srcs/builtins/set.c:		if (new_positional_var(shell, process->av[i], i) != SUCCESS)
srcs/builtins/set.c:	argc = ft_tablen(process->av);
srcs/builtins/set.c:	if ((parsing_ret = parse_set(argc, process->av)) > 0)
srcs/builtins/test.c:/*   Created: 2020/01/20 17:50:06 by mpivet-p          #+#    #+#             */
srcs/builtins/test.c:/*   Updated: 2020/03/08 14:27:32 by mpivet-p         ###   ########.fr       */
srcs/builtins/test.c:	static char	*op[NB_TESTBLT] = {"-b", "-c", "-d", "-e", "-f", "-g", "-L"
srcs/builtins/test.c:		, "-p", "-r", "-S", "-s", "-u", "-w", "-x", "-z", "=", "!=", "-eq"
srcs/builtins/test.c:		, "-ne", "-ge", "-lt", "-le"};
srcs/builtins/test.c:		return (((ft_strcmp(s1, s2) == 0) ? 1 : 0) ^ (DIFF_BINTEST - opt));
srcs/builtins/test.c:		return ((n1 == n2) ^ (NE_BINTEST - opt));
srcs/builtins/test.c:		return ((n1 >= n2) ^ (LT_BINTEST - opt));
srcs/builtins/test.c:	argc = ft_tablen(process->av);
srcs/builtins/test.c:	diff = (argc > 1 && process->av[1]
srcs/builtins/test.c:	&& ft_strcmp(process->av[1], "!") == 0) ? 1 : 0;
srcs/builtins/test.c:			|| process->av[1 + diff][0] == 0) ? 1 : 0) ^ diff);
srcs/builtins/test.c:	parse_testblt(argc, process->av, diff, &opt);
srcs/builtins/test.c:		return (path_tests(process->av[2 + diff], opt) ^ diff);
srcs/builtins/test.c:		return (comp_tests(process->av[1 + diff]
srcs/builtins/test.c:			, process->av[3 + diff], opt) ^ diff);
srcs/builtins/type.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/builtins/type.c:/*   Created: 2019/12/16 05:41:09 by mpivet-p          #+#    #+#             */
srcs/builtins/type.c:/*   Updated: 2020/03/08 14:29:02 by mpivet-p         ###   ########.fr       */
srcs/builtins/type.c:	while (process->av[i])
srcs/builtins/type.c:		ret = type(shell, process->av[i]);
srcs/builtins/unset.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/builtins/unset.c:/*   Created: 2019/09/29 03:59:34 by mpivet-p          #+#    #+#             */
srcs/builtins/unset.c:/*   Updated: 2020/03/08 14:29:12 by mpivet-p         ###   ########.fr       */
srcs/builtins/unset.c:		free_hash_map(&shell->hash);
srcs/builtins/unset.c:	argc = ft_tablen(process->av);
srcs/builtins/unset.c:	i = (argc > 1 && process->av[1][0] != '-') ? 0 : 1;
srcs/builtins/unset.c:	if ((parsing_ret = parse_unset(argc, process->av) > 0))
srcs/builtins/unset.c:		if (check_invalid_identifiers(process->av[i], "") != SUCCESS)
srcs/builtins/unset.c:			, "42sh: unset: `%s': not a valid identifier\n", process->av[i]);
srcs/builtins/unset.c:			unset_hash_handler(shell, process->av[i]);
srcs/builtins/unset.c:			del_db(shell, process->av[i]);
srcs/cmdline/action_keys/check_caps.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/cmdline/action_keys/check_caps.c:/*   Updated: 2020/03/08 14:39:42 by mpivet-p         ###   ########.fr       */
srcs/cmdline/action_keys/check_caps.c:	i = term->width - term->x_index;
srcs/cmdline/action_keys/check_caps.c:		while (term->x_index > term->prompt_len)
srcs/cmdline/action_keys/check_caps.c:		while (term->x_index < term->width)
srcs/cmdline/action_keys/check_caps.c:		while (i--)
srcs/cmdline/action_keys/check_caps.c:	*value = get_mask(term->ac_tmp);
srcs/cmdline/action_keys/check_caps.c:	if (term->tmp_buff && ft_is_print(*term->ac_tmp))
srcs/cmdline/action_keys/check_caps.c:		insert_in_buffer(term->ac_tmp, term);
srcs/cmdline/action_keys/check_caps.c:	ft_strdel(&term->ac_tmp);
srcs/cmdline/action_keys/check_caps.c:	if (term->status == CMD_SUBPROMPT)
srcs/cmdline/action_keys/check_caps.c:		if (!*term->buffer)
srcs/cmdline/action_keys/check_caps.c:			term->flag = TRUE;
srcs/cmdline/action_keys/check_caps.c:		if (*term->prompt || (!*term->prompt && *term->buffer))
srcs/cmdline/action_keys/del_keys.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/cmdline/action_keys/del_keys.c:/*   Updated: 2020/03/08 14:39:53 by mpivet-p         ###   ########.fr       */
srcs/cmdline/action_keys/del_keys.c:**	- `del' => Delete one char position at the cursor
srcs/cmdline/action_keys/del_keys.c:**	- `clr_lines' => clear the line the cursor is on, and following lines
srcs/cmdline/action_keys/del_keys.c:**	- `reset_cr' => restore the cursor position
srcs/cmdline/action_keys/del_keys.c:**	- `save_cr' => save cursor position
srcs/cmdline/action_keys/del_keys.c:	xtputs(term->tcaps[DEL_CR], 1, my_outc);
srcs/cmdline/action_keys/del_keys.c:	xtputs(term->tcaps[SAVE_CR], 1, my_outc);
srcs/cmdline/action_keys/del_keys.c:	xtputs(term->tcaps[CLR_LINES], 1, my_outc);
srcs/cmdline/action_keys/del_keys.c:	xtputs(term->tcaps[RESTORE_CR], 1, my_outc);
srcs/cmdline/action_keys/del_keys.c:	if (*term->buffer && term->x >= term->prompt_len * (term->y == 0 ? 1 : 0)
srcs/cmdline/action_keys/del_keys.c:		&& term->x < term->width)
srcs/cmdline/action_keys/del_keys.c:		i = term->x_index - term->prompt_len - 1;
srcs/cmdline/action_keys/del_keys.c:		while (term->buffer[++i])
srcs/cmdline/action_keys/del_keys.c:			term->buffer[i] = term->buffer[i + 1];
srcs/cmdline/action_keys/del_keys.c:		x = term->x;
srcs/cmdline/action_keys/del_keys.c:		i = term->x_index;
srcs/cmdline/action_keys/del_keys.c:		y = term->y;
srcs/cmdline/action_keys/del_keys.c:		w = term->width - 1;
srcs/cmdline/action_keys/del_keys.c:		ft_putstr_fd(term->buffer, STDERR_FILENO);
srcs/cmdline/action_keys/del_keys.c:		term->x = x;
srcs/cmdline/action_keys/del_keys.c:		term->x_index = i;
srcs/cmdline/action_keys/del_keys.c:		term->y = y;
srcs/cmdline/action_keys/del_keys.c:		term->width = w;
srcs/cmdline/action_keys/del_keys.c:		xtputs(term->tcaps[RESTORE_CR], 1, my_outc);
srcs/cmdline/action_keys/del_keys.c:	if ((term->y > 0 && term->x >= 0) || term->x > term->prompt_len)
srcs/cmdline/action_keys/insert_in_buffer.c:/*   Updated: 2020/03/08 14:40:13 by mpivet-p         ###   ########.fr       */
srcs/cmdline/action_keys/insert_in_buffer.c:	if (buff == NEW_LINE[0] || term->x >= term->ws_col)
srcs/cmdline/action_keys/insert_in_buffer.c:			term->x = -1;
srcs/cmdline/action_keys/insert_in_buffer.c:			term->x = 0;
srcs/cmdline/action_keys/insert_in_buffer.c:		term->y++;
srcs/cmdline/action_keys/insert_in_buffer.c:	term->x++;
srcs/cmdline/action_keys/insert_in_buffer.c:	term->width++;
srcs/cmdline/action_keys/insert_in_buffer.c:	term->buffer[buff_index] = buff;
srcs/cmdline/action_keys/insert_in_buffer.c:	term->x_index++;
srcs/cmdline/action_keys/insert_in_buffer.c:	j = ft_strlen(term->buffer) + 1;
srcs/cmdline/action_keys/insert_in_buffer.c:	while (--j > buff_index)
srcs/cmdline/action_keys/insert_in_buffer.c:		term->buffer[j] = term->buffer[j - 1];
srcs/cmdline/action_keys/insert_in_buffer.c:	term->buffer[buff_index] = *buff;
srcs/cmdline/action_keys/insert_in_buffer.c:	tmp = ft_strdup(term->buffer);
srcs/cmdline/action_keys/insert_in_buffer.c:	ft_strdel(&term->buffer);
srcs/cmdline/action_keys/insert_in_buffer.c:	term->buffer = ft_memalloc(BUFF_SIZE);
srcs/cmdline/action_keys/insert_in_buffer.c:	x = buff_index + term->prompt_len;
srcs/cmdline/action_keys/insert_in_buffer.c:	while (++x < term->width)
srcs/cmdline/action_keys/insert_in_buffer.c:	while (i--)
srcs/cmdline/action_keys/insert_in_buffer.c:		buff_index = term->x_index - term->prompt_len;
srcs/cmdline/action_keys/insert_in_buffer.c:		if (term->x_index < term->width)
srcs/cmdline/action_keys/insert_in_buffer.c:	buff_index = term->x_index - term->prompt_len;
srcs/cmdline/action_keys/insert_in_buffer.c:	if (term->x_index >= BUFF_SIZE || term->x_index + len >= BUFF_SIZE)
srcs/cmdline/action_keys/insert_in_buffer.c:		increase_len = ft_strlen(term->buffer) + READ_SIZE;
srcs/cmdline/action_keys/insert_in_buffer.c:		term->buffer = ft_realloc(term->buffer, increase_len);
srcs/cmdline/action_keys/insert_in_buffer.c:	else if (term->x_index == term->width)
srcs/cmdline/action_keys/insert_in_buffer.c:	else if (term->x_index < term->width)
srcs/cmdline/action_keys/keys_comb.c:/*   Updated: 2020/03/08 14:40:24 by mpivet-p         ###   ########.fr       */
srcs/cmdline/action_keys/keys_comb.c:	x_saved = term->x_index;
srcs/cmdline/action_keys/keys_comb.c:	tmp = ft_strdup(term->buffer);
srcs/cmdline/action_keys/keys_comb.c:	xtputs(term->tcaps[CLEAR], 1, my_outc);
srcs/cmdline/action_keys/keys_comb.c:	ft_dprintf(STDERR_FILENO, "%s%s%s%s", C_BOLD, C_Y, term->prompt, C_X);
srcs/cmdline/action_keys/keys_comb.c:	ft_strdel(&term->buffer);
srcs/cmdline/action_keys/keys_comb.c:	term->buffer = ft_memalloc(BUFF_SIZE);
srcs/cmdline/action_keys/keys_comb.c:	i = term->x_index - x_saved;
srcs/cmdline/action_keys/keys_comb.c:	while (i--)
srcs/cmdline/action_keys/keys_comb.c:	xtputs(term->tcaps[KEY_UP], 1, my_outc);
srcs/cmdline/action_keys/keys_comb.c:	if (term->x < term->prompt_len && term->y == 1)
srcs/cmdline/action_keys/keys_comb.c:		while ((term->x)++ < term->prompt_len)
srcs/cmdline/action_keys/keys_comb.c:			xtputs(term->tcaps[KEY_RIGHT], 1, my_outc);
srcs/cmdline/action_keys/keys_comb.c:		term->x_index = term->x;
srcs/cmdline/action_keys/keys_comb.c:		if (term->y == 1)
srcs/cmdline/action_keys/keys_comb.c:			term->x_index = term->x;
srcs/cmdline/action_keys/keys_comb.c:			term->x_index -= width;
srcs/cmdline/action_keys/keys_comb.c:	term->y--;
srcs/cmdline/action_keys/keys_comb.c:	width = get_width_current_line(term) - term->x;
srcs/cmdline/action_keys/keys_comb.c:		nb_ofline = term->width / term->ws_col;
srcs/cmdline/action_keys/keys_comb.c:	if (term->y < nb_ofline)
srcs/cmdline/action_keys/keys_comb.c:		xtputs(term->tcaps[KEY_DOWN], 1, my_outc);
srcs/cmdline/action_keys/keys_comb.c:		term->x_index = term->x_index + width + 1;
srcs/cmdline/action_keys/keys_comb.c:		term->x = 0;
srcs/cmdline/action_keys/keys_comb.c:		term->y++;
srcs/cmdline/action_keys/keys_comb.c:	if (value == ALT_AW_UP && term->y > 0)
srcs/cmdline/action_keys/keys_comb.c:		if (term->buffer[term->x_index - term->prompt_len] != ' ')
srcs/cmdline/action_keys/keys_comb.c:		while (term->x_index > term->prompt_len
srcs/cmdline/action_keys/keys_comb.c:			&& term->buffer[term->x_index - term->prompt_len] == ' ')
srcs/cmdline/action_keys/keys_comb.c:		while (term->x_index > term->prompt_len
srcs/cmdline/action_keys/keys_comb.c:			&& term->buffer[term->x_index - term->prompt_len - 1] != ' ')
srcs/cmdline/action_keys/keys_comb.c:		if (term->buffer[term->x_index - term->prompt_len] != ' ')
srcs/cmdline/action_keys/keys_comb.c:		while (term->x_index < term->width
srcs/cmdline/action_keys/keys_comb.c:			&& term->buffer[term->x_index - term->prompt_len] == ' ')
srcs/cmdline/action_keys/keys_comb.c:		while (term->x_index < term->width
srcs/cmdline/action_keys/keys_comb.c:			&& term->buffer[term->x_index - term->prompt_len] != ' ')
srcs/cmdline/action_keys/move_cursor.c:	ft_strdel(&term->buffer);
srcs/cmdline/action_keys/move_cursor.c:	term->buffer = ft_memalloc(BUFF_SIZE);
srcs/cmdline/action_keys/move_cursor.c:	if (term->tmp_buff && ft_strlen(term->tmp_buff) > 0)
srcs/cmdline/action_keys/move_cursor.c:		insert_str_in_buffer(term->tmp_buff, term);
srcs/cmdline/action_keys/move_cursor.c:		ft_strdel(&(term->tmp_buff));
srcs/cmdline/action_keys/move_cursor.c:		term->history_index = NULL;
srcs/cmdline/action_keys/move_cursor.c:	if (term->history && term->history_index)
srcs/cmdline/action_keys/move_cursor.c:		if (term->history_index && term->history_index->prev)
srcs/cmdline/action_keys/move_cursor.c:			w = term->history_index->prev;
srcs/cmdline/action_keys/move_cursor.c:			term->history_index = w;
srcs/cmdline/action_keys/move_cursor.c:			term->history_index = w;
srcs/cmdline/action_keys/move_cursor.c:		ft_strdel(&term->buffer);
srcs/cmdline/action_keys/move_cursor.c:		term->buffer = ft_memalloc(BUFF_SIZE);
srcs/cmdline/action_keys/move_cursor.c:		insert_str_in_buffer((char*)w->content, term);
srcs/cmdline/action_keys/move_cursor.c:	if (term->history)
srcs/cmdline/action_keys/move_cursor.c:		if (term->history_index && !term->history_index->next)
srcs/cmdline/action_keys/move_cursor.c:		if (term->history_index && term->history_index->next)
srcs/cmdline/action_keys/move_cursor.c:			w = term->history_index->next;
srcs/cmdline/action_keys/move_cursor.c:			term->history_index = w;
srcs/cmdline/action_keys/move_cursor.c:			if (*term->buffer)
srcs/cmdline/action_keys/move_cursor.c:				term->tmp_buff = ft_strdup(term->buffer);
srcs/cmdline/action_keys/move_cursor.c:			term->history_index = term->history;
srcs/cmdline/action_keys/move_cursor.c:			w = term->history;
srcs/cmdline/action_keys/move_cursor.c:		ft_strdel(&term->buffer);
srcs/cmdline/action_keys/move_cursor.c:		term->buffer = ft_memalloc(BUFF_SIZE);
srcs/cmdline/action_keys/move_cursor.c:		insert_str_in_buffer((char*)w->content, term);
srcs/cmdline/action_keys/move_cursor.c:	buff_index = term->x_index - term->prompt_len;
srcs/cmdline/action_keys/move_cursor.c:	if (term->x < width)
srcs/cmdline/action_keys/move_cursor.c:		xtputs(term->tcaps[KEY_RIGHT], 1, my_outc);
srcs/cmdline/action_keys/move_cursor.c:		term->x_index++;
srcs/cmdline/action_keys/move_cursor.c:		term->x++;
srcs/cmdline/action_keys/move_cursor.c:	else if (term->x >= term->ws_col - 1 || *buff == NEW_LINE[0]
srcs/cmdline/action_keys/move_cursor.c:			|| term->buffer[buff_index] == NEW_LINE[0])
srcs/cmdline/action_keys/move_cursor.c:		xtputs(term->tcaps[LEFT_MARGIN], 1, my_outc);
srcs/cmdline/action_keys/move_cursor.c:		xtputs(term->tcaps[KEY_DOWN], 1, my_outc);
srcs/cmdline/action_keys/move_cursor.c:		term->x_index++;
srcs/cmdline/action_keys/move_cursor.c:		term->x = 0;
srcs/cmdline/action_keys/move_cursor.c:		term->y++;
srcs/cmdline/action_keys/move_cursor.c:	if ((term->x > term->prompt_len && term->y == 0)
srcs/cmdline/action_keys/move_cursor.c:		|| (term->x > 0 && term->y > 0))
srcs/cmdline/action_keys/move_cursor.c:		xtputs(term->tcaps[KEY_LEFT], 1, my_outc);
srcs/cmdline/action_keys/move_cursor.c:		term->x_index--;
srcs/cmdline/action_keys/move_cursor.c:		term->x--;
srcs/cmdline/action_keys/move_cursor.c:	else if (term->y > 0 && term->x == 0)
srcs/cmdline/action_keys/move_cursor.c:		term->x = width;
srcs/cmdline/action_keys/move_cursor.c:		while (width--)
srcs/cmdline/action_keys/move_cursor.c:			xtputs(term->tcaps[KEY_RIGHT], 1, my_outc);
srcs/cmdline/action_keys/move_cursor.c:		xtputs(term->tcaps[KEY_UP], 1, my_outc);
srcs/cmdline/action_keys/move_cursor.c:		term->x_index--;
srcs/cmdline/action_keys/move_cursor.c:		term->y--;
srcs/cmdline/auto_c/ac_bin.c:/*   Updated: 2020/03/08 14:41:04 by mpivet-p         ###   ########.fr       */
srcs/cmdline/auto_c/ac_bin.c:	i = -1;
srcs/cmdline/auto_c/ac_bin.c:	ft_strdel(&term->buffer);
srcs/cmdline/auto_c/ac_bin.c:	term->buffer = ft_memalloc(BUFF_SIZE);
srcs/cmdline/auto_c/ac_bin.c:			term->ac_tmp = ft_strdup(buff);
srcs/cmdline/auto_c/ac_bin.c:		insert_bin_in_buffer(bin->content, term);
srcs/cmdline/auto_c/ac_bin.c:			if (!bin->next)
srcs/cmdline/auto_c/ac_bin.c:				bin = bin->next;
srcs/cmdline/auto_c/ac_bin.c:	i = -1;
srcs/cmdline/auto_c/ac_bin.c:	path = split_path(term->shell, "PATH");
srcs/cmdline/auto_c/ac_bin.c:			if ((!*to_find || ft_isstart(data->d_name, to_find))
srcs/cmdline/auto_c/ac_bin.c:			&& is_a_blt(data->d_name) == -1 && !ft_isstart(data->d_name, "."))
srcs/cmdline/auto_c/ac_bin.c:				ft_lstappend(&bin, ft_lstnew(data->d_name,
srcs/cmdline/auto_c/ac_bin.c:							sizeof(char) * (ft_strlen(data->d_name) + 1)));
srcs/cmdline/auto_c/ac_buffer.c:/*   Updated: 2020/03/08 14:41:15 by mpivet-p         ###   ########.fr       */
srcs/cmdline/auto_c/ac_buffer.c:			term->ac_tmp = ft_strdup(buff);
srcs/cmdline/auto_c/ac_buffer.c:			term->flag = FALSE;
srcs/cmdline/auto_c/ac_buffer.c:	found = ft_strlen(term->cmd[0]);
srcs/cmdline/auto_c/ac_buffer.c:	while (found--)
srcs/cmdline/auto_c/ac_buffer.c:		if (term->cmd[0][found] == '/')
srcs/cmdline/auto_c/ac_buffer.c:			ft_strncpy(current_dir, term->cmd[1], found + 1);
srcs/cmdline/auto_c/ac_buffer.c:			tmp = ft_strdup(ft_strrchr(term->cmd[0], '/'));
srcs/cmdline/auto_c/ac_buffer.c:			ft_strdel(&term->cmd[0]);
srcs/cmdline/auto_c/ac_buffer.c:			term->cmd[0] = ft_strdup(tmp + 1);
srcs/cmdline/auto_c/ac_buffer.c:		tmp = ft_strdup(term->cmd[0]);
srcs/cmdline/auto_c/ac_buffer.c:		ft_strdel(&term->cmd[1]);
srcs/cmdline/auto_c/ac_buffer.c:		term->cmd[1] = ft_strdup(tmp);
srcs/cmdline/auto_c/ac_buffer.c:**		Return FAILURE(-1) to stop reading
srcs/cmdline/auto_c/ac_buffer.c:		if (ft_isstart(data->d_name, term->cmd[0]))
srcs/cmdline/auto_c/ac_buffer.c:			term->flag = TRUE;
srcs/cmdline/auto_c/ac_buffer.c:			path = ft_strjoin(current_dir, data->d_name);
srcs/cmdline/auto_c/ac_buffer.c:			if (read_again(&term->cmd[1], path, data->d_name, term) == TRUE)
srcs/cmdline/auto_c/ac_buffer.c:	if (term->flag == TRUE)
srcs/cmdline/auto_c/ac_buffer.c:	term->flag = FALSE;
srcs/cmdline/auto_c/ac_buffer.c:	ft_tabfree(term->cmd);
srcs/cmdline/auto_c/ac_buffer.c:	term->cmd = ft_memalloc(BUFF_SIZE);
srcs/cmdline/auto_c/ac_buffer.c:	term->cmd[0] = ft_strdup(to_find);
srcs/cmdline/auto_c/ac_buffer.c:	term->cmd[1] = ft_strdup(to_find);
srcs/cmdline/auto_c/ac_buffer.c:		parse_env(&term->cmd[1], term->cmd[0], term);
srcs/cmdline/auto_c/ac_current_dir.c:/*   Updated: 2020/03/08 14:41:34 by mpivet-p         ###   ########.fr       */
srcs/cmdline/auto_c/ac_current_dir.c:			term->ac_tmp = ft_strdup(buff);
srcs/cmdline/auto_c/ac_current_dir.c:	if (term->ac > 1 && is_dir(av))
srcs/cmdline/auto_c/ac_current_dir.c:		term->flag++;
srcs/cmdline/auto_c/ac_current_dir.c:		if (is_dot(data->d_name) == FALSE)
srcs/cmdline/auto_c/ac_current_dir.c:			ft_strcat(tmp, data->d_name);
srcs/cmdline/auto_c/ac_current_dir.c:				ft_strcat(data->d_name, "/");
srcs/cmdline/auto_c/ac_current_dir.c:			insert_str_in_buffer(data->d_name, term);
srcs/cmdline/auto_c/ac_current_dir.c:		if (is_tab(data->d_name, term) == TRUE)
srcs/cmdline/auto_c/ac_current_dir.c:	term->flag = FALSE;
srcs/cmdline/auto_c/ac_current_dir.c:	(term->flag != 2) ? display_current_directory(term, av) : 0;
srcs/cmdline/auto_c/ac_directories.c:		term->flag = TRUE;
srcs/cmdline/auto_c/ac_directories.c:			if (ac_dir(term, data->d_name, to_find) == SUCCESS)
srcs/cmdline/auto_c/ac_directories.c:				term->flag = FALSE;
srcs/cmdline/auto_c/ac_directories.c:		term->flag = FALSE;
srcs/cmdline/auto_c/ac_directories.c:	term->flag == TRUE ? read_directories(to_find, term) : 0;
srcs/cmdline/auto_c/ac_tools.c:	env = shell->env;
srcs/cmdline/auto_c/ac_tools.c:		if (!ft_strcmp(str, ((t_db*)(env->content))->key))
srcs/cmdline/auto_c/ac_tools.c:			array = ft_strsplit(((t_db*)(env->content))->value, ":");
srcs/cmdline/auto_c/ac_tools.c:		env = env->next;
srcs/cmdline/auto_c/ac_tools.c:	i = -1;
srcs/cmdline/auto_c/ac_tools.c:	term->ac = 0;
srcs/cmdline/auto_c/ac_tools.c:	while (ft_isblank(term->buffer[++i]))
srcs/cmdline/auto_c/ac_tools.c:	if (term->buffer[i] == '\0')
srcs/cmdline/auto_c/ac_tools.c:		term->cmd = ft_memalloc(BUFF_SIZE);
srcs/cmdline/auto_c/ac_tools.c:	if ((term->cmd = ft_strsplit(term->buffer, SPACE)) == NULL)
srcs/cmdline/auto_c/ac_tools.c:	term->ac = ft_tablen(term->cmd);
srcs/cmdline/auto_c/ac_tools.c:	if (term->buffer[ft_strlen(term->buffer) - 1] == ' ')
srcs/cmdline/auto_c/ac_tools.c:		term->ac += 1;
srcs/cmdline/auto_c/ac_tools.c:	if (!(*to_find = ft_strdup(term->cmd[ft_tablen(term->cmd) - 1])))
srcs/cmdline/auto_c/ac_var.c:	env = term->shell->env;
srcs/cmdline/auto_c/ac_var.c:	term->flag = FALSE;
srcs/cmdline/auto_c/ac_var.c:	while (env->next)
srcs/cmdline/auto_c/ac_var.c:		if (var_is_matching(to_find, ((t_db *)(env->content))->key) == TRUE)
srcs/cmdline/auto_c/ac_var.c:			insert_dollar(&insert, to_find, ((t_db *)(env->content))->key);
srcs/cmdline/auto_c/ac_var.c:			term->flag = TRUE;
srcs/cmdline/auto_c/ac_var.c:		env = env->next;
srcs/cmdline/auto_c/ac_var.c:	(term->flag == TRUE) ? parse_env(prev_b, to_find, term) : 0;
srcs/cmdline/auto_c/auto_completion.c:	i = term->width - term->prompt_len - ft_strlen(d_name);
srcs/cmdline/auto_c/auto_completion.c:	tmp = ft_strsub(term->buffer, 0, i);
srcs/cmdline/auto_c/auto_completion.c:	ft_strdel(&term->buffer);
srcs/cmdline/auto_c/auto_completion.c:	term->buffer = ft_memalloc(BUFF_SIZE);
srcs/cmdline/auto_c/auto_completion.c:**		- complete bin for the first argument only
srcs/cmdline/auto_c/auto_completion.c:**		- display all files of current dir
srcs/cmdline/auto_c/auto_completion.c:**		- complete char inserted with matching file
srcs/cmdline/auto_c/auto_completion.c:**		- complete directories recursively
srcs/cmdline/auto_c/auto_completion.c:	i = term->x_index - term->prompt_len - 1;
srcs/cmdline/auto_c/auto_completion.c:	if (term->ac > 1)
srcs/cmdline/auto_c/auto_completion.c:		if (term->buffer[i] == ' ' || (is_dir(to_find)
srcs/cmdline/auto_c/auto_completion.c:			&& !is_dot(&to_find[ft_strlen(to_find) - 1])))
srcs/cmdline/auto_c/auto_completion.c:	else if (term->ac <= 1)
srcs/cmdline/auto_c/auto_completion.c:		if (is_dir(term->buffer) || ft_isstart(term->buffer, "/"))
srcs/cmdline/auto_c/auto_completion.c:		else if (!*term->buffer || ft_isalpha(*to_find))
srcs/cmdline/auto_c/auto_completion.c:		else if (term->flag == FALSE)
srcs/cmdline/auto_c/auto_completion.c:	ft_tabfree(term->cmd);
srcs/cmdline/history/exp/check_hst_exp.c:/*   Updated: 2020/03/08 14:42:18 by mpivet-p         ###   ########.fr       */
srcs/cmdline/history/exp/check_hst_exp.c:	if (term->buffer[*i + 1] == '!')
srcs/cmdline/history/exp/check_hst_exp.c:	else if (ft_isdigit(term->buffer[*i + 1]))
srcs/cmdline/history/exp/check_hst_exp.c:	else if (ft_isalpha(term->buffer[*i + 1]))
srcs/cmdline/history/exp/check_hst_exp.c:	else if (term->buffer[*i + 1] == '-' && ft_isdigit(term->buffer[*i + 2]))
srcs/cmdline/history/exp/check_hst_exp.c:	i = -1;
srcs/cmdline/history/exp/check_hst_exp.c:	tmp = ft_strdup(term->buffer);
srcs/cmdline/history/exp/check_hst_exp.c:	while (term->buffer[++i])
srcs/cmdline/history/exp/check_hst_exp.c:		if (term->buffer[i] == '!')
srcs/cmdline/history/exp/check_hst_exp.c:	if (ft_strcmp(tmp, term->buffer))
srcs/cmdline/history/exp/check_hst_exp.c:		ft_dprintf(STDERR_FILENO, "%s\n", term->buffer);
srcs/cmdline/history/exp/history_expansions.c:	j = -1;
srcs/cmdline/history/exp/history_expansions.c:	w = term->history;
srcs/cmdline/history/exp/history_expansions.c:	while (n < (int)ft_strlen(term->buffer) && !ft_isblank(term->buffer[n]))
srcs/cmdline/history/exp/history_expansions.c:		word[++j] = term->buffer[n];
srcs/cmdline/history/exp/history_expansions.c:	while (w->next && ft_isstart((char *)w->content, word) == FALSE)
srcs/cmdline/history/exp/history_expansions.c:		w = w->next;
srcs/cmdline/history/exp/history_expansions.c:	if (!w->next)
srcs/cmdline/history/exp/history_expansions.c:	insert_content(j + 2, i, term, (char *)w->content);
srcs/cmdline/history/exp/history_expansions.c:	return (i + ft_strlen((char *)w->content) - 1);
srcs/cmdline/history/exp/history_expansions.c:**		"!-number" expansion search from the end of hst lst
srcs/cmdline/history/exp/history_expansions.c:	j = -1;
srcs/cmdline/history/exp/history_expansions.c:	w = term->history;
srcs/cmdline/history/exp/history_expansions.c:	while (ft_isdigit(term->buffer[n]))
srcs/cmdline/history/exp/history_expansions.c:		nb[++j] = term->buffer[n];
srcs/cmdline/history/exp/history_expansions.c:	while (w && n != 0 && --n)
srcs/cmdline/history/exp/history_expansions.c:		if (w->next)
srcs/cmdline/history/exp/history_expansions.c:			w = w->next;
srcs/cmdline/history/exp/history_expansions.c:	insert_content(j + 3, i, term, (char *)w->content);
srcs/cmdline/history/exp/history_expansions.c:	j = -1;
srcs/cmdline/history/exp/history_expansions.c:	w = term->history;
srcs/cmdline/history/exp/history_expansions.c:	while (ft_isdigit(term->buffer[n]))
srcs/cmdline/history/exp/history_expansions.c:		nb[++j] = term->buffer[n];
srcs/cmdline/history/exp/history_expansions.c:	while (w->next)
srcs/cmdline/history/exp/history_expansions.c:		w = w->next;
srcs/cmdline/history/exp/history_expansions.c:	while (w && n != 0 && --n)
srcs/cmdline/history/exp/history_expansions.c:		if (w->prev)
srcs/cmdline/history/exp/history_expansions.c:			w = w->prev;
srcs/cmdline/history/exp/history_expansions.c:	insert_content(j + 2, i, term, (char *)w->content);
srcs/cmdline/history/exp/history_expansions.c:	w = term->history;
srcs/cmdline/history/exp/history_expansions.c:	if (!term->history || ft_strlen(term->buffer) > BUFF_SIZE)
srcs/cmdline/history/exp/history_expansions.c:	if (w && w->content)
srcs/cmdline/history/exp/history_expansions.c:		insert_content(2, i, term, (char *)w->content);
srcs/cmdline/history/exp/history_expansions.c:	len = i + ft_strlen((char *)w->content);
srcs/cmdline/history/exp/history_expansions.c:	return (len - 1);
srcs/cmdline/history/exp/replace_buffer.c:	if (term->width - term->prompt_len == 2)
srcs/cmdline/history/exp/replace_buffer.c:		term->buffer = ft_strdup(content);
srcs/cmdline/history/exp/replace_buffer.c:		term->buffer = ft_strjoinf(tmp, end, 3);
srcs/cmdline/history/exp/replace_buffer.c:		term->buffer = ft_strjoinf(content, end, 2);
srcs/cmdline/history/exp/replace_buffer.c:		term->buffer = ft_strjoinf(begin, content, 1);
srcs/cmdline/history/exp/replace_buffer.c:		term->buffer = ft_strdup(content);
srcs/cmdline/history/exp/replace_buffer.c:	buff_len = ft_strlen(term->buffer);
srcs/cmdline/history/exp/replace_buffer.c:		inc_len = ft_strlen(term->buffer) + ft_strlen((char *)content);
srcs/cmdline/history/exp/replace_buffer.c:		term->buffer = ft_realloc(term->buffer, inc_len);
srcs/cmdline/history/exp/replace_buffer.c:		begin = ft_strsub(term->buffer, 0, i);
srcs/cmdline/history/exp/replace_buffer.c:		end = ft_strsub(term->buffer, i + j, buff_len - (i + j));
srcs/cmdline/history/exp/replace_buffer.c:	ft_strdel(&term->buffer);
srcs/cmdline/history/save_history.c:/*   Updated: 2020/03/08 14:41:56 by mpivet-p         ###   ########.fr       */
srcs/cmdline/history/save_history.c:	while (hst->next && ++i < HIST_SIZE)
srcs/cmdline/history/save_history.c:		hst = hst->next;
srcs/cmdline/history/save_history.c:		if (write(fd, hst->content, ft_strlen(hst->content)) == FAILURE
srcs/cmdline/history/save_history.c:		hst = hst->prev;
srcs/cmdline/history/save_history.c:	if (!shell->term.history)
srcs/cmdline/history/save_history.c:				, (S_IRUSR | S_IWUSR) | (S_IRGRP | S_IROTH))) == -1)
srcs/cmdline/history/save_history.c:	return (history_writer(shell->term.history, fd));
srcs/cmdline/history/save_history.c:	if (term->buffer && *term->buffer)
srcs/cmdline/history/save_history.c:		saved->prev = NULL;
srcs/cmdline/history/save_history.c:		saved->next = term->history;
srcs/cmdline/history/save_history.c:		saved->content = ft_strdup(term->buffer);
srcs/cmdline/history/save_history.c:		if (term->history)
srcs/cmdline/history/save_history.c:			term->history->prev = saved;
srcs/cmdline/history/save_history.c:		term->history = saved;
srcs/cmdline/history/save_history.c:		term->history_index = NULL;
srcs/cmdline/history/save_history.c:		if (term->history->next)
srcs/cmdline/history/save_history.c:			term->history->content_size = term->history->next->content_size + 1;
srcs/cmdline/history/save_history.c:			shell->term.buffer = ft_strdup(line);
srcs/cmdline/history/save_history.c:			save_history(&shell->term);
srcs/cmdline/history/save_history.c:			shell->term.history->content_size = ++i;
srcs/cmdline/history/save_history.c:			ft_strdel(&(shell->term.buffer));
srcs/cmdline/history/save_history.c:**	Init history list -> load datas from history file
srcs/cmdline/history/save_history.c:	if ((fd = open(history_file, O_RDONLY, S_IRUSR | S_IRGRP | S_IROTH)) == -1)
srcs/cmdline/history/search_in_history.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/cmdline/history/search_in_history.c:/*   Updated: 2020/03/08 14:42:04 by mpivet-p         ###   ########.fr       */
srcs/cmdline/history/search_in_history.c:	xtputs(term->tcaps[LEFT_MARGIN], 1, my_outc);
srcs/cmdline/history/search_in_history.c:	xtputs(term->tcaps[CLR_LINES], 1, my_outc);
srcs/cmdline/history/search_in_history.c:		ft_dprintf(STDERR_FILENO, "(reverse-i-search)`%s': ", buff_tmp);
srcs/cmdline/history/search_in_history.c:		ft_dprintf(STDERR_FILENO, "(failed reverse-i-search)`%s': ", buff_tmp);
srcs/cmdline/history/search_in_history.c:	while ((*history)->next && *buff_tmp)
srcs/cmdline/history/search_in_history.c:		if (ft_strstr((*history)->content, buff_tmp))
srcs/cmdline/history/search_in_history.c:			ft_bzero(term->buffer, ft_strlen(term->buffer));
srcs/cmdline/history/search_in_history.c:			term->x = ft_strlen(buff_tmp) + 23;
srcs/cmdline/history/search_in_history.c:			insert_str_in_buffer((*history)->content, term);
srcs/cmdline/history/search_in_history.c:			if ((*history)->next)
srcs/cmdline/history/search_in_history.c:				(*history) = (*history)->next;
srcs/cmdline/history/search_in_history.c:		(*history) = (*history)->next;
srcs/cmdline/history/search_in_history.c:		term->tmp_buff[++(*i)] = *buff;
srcs/cmdline/history/search_in_history.c:		goto_reverse(term, term->tmp_buff, SUCCESS);
srcs/cmdline/history/search_in_history.c:	else if (value == BS_KEY && *term->tmp_buff)
srcs/cmdline/history/search_in_history.c:		term->tmp_buff[*i] = 0;
srcs/cmdline/history/search_in_history.c:		if (*i <= -1)
srcs/cmdline/history/search_in_history.c:		(*i)--;
srcs/cmdline/history/search_in_history.c:	i = -1;
srcs/cmdline/history/search_in_history.c:	term->tmp_buff = ft_memalloc(BUFF_SIZE);
srcs/cmdline/history/search_in_history.c:	history = term->history;
srcs/cmdline/history/search_in_history.c:		if (!term->tmp_buff)
srcs/cmdline/history/search_in_history.c:			ft_strdel(&term->tmp_buff);
srcs/cmdline/history/search_in_history.c:		walking_history(term->tmp_buff, term, &history);
srcs/cmdline/history/search_in_history.c:	if (term->tmp_buff)
srcs/cmdline/history/search_in_history.c:		saved = ft_strdup(term->tmp_buff);
srcs/cmdline/history/search_in_history.c:		ft_strdel(&term->tmp_buff);
srcs/cmdline/history/search_in_history.c:		term->tmp_buff = ft_strdup(saved);
srcs/cmdline/history/search_in_history.c:	ft_dprintf(STDIN_FILENO, "%s", term->buffer);
srcs/cmdline/history/search_in_history.c:	term->x += ft_strlen(term->buffer);
srcs/cmdline/history/search_in_history.c:	term->width = term->x;
srcs/cmdline/history/search_in_history.c:	term->x_index = term->x;
srcs/cmdline/history/search_in_history.c:	term->y = term->width / term->ws_col;
srcs/cmdline/init_termcaps.c:/*   Updated: 2020/03/08 14:38:19 by mpivet-p         ###   ########.fr       */
srcs/cmdline/init_termcaps.c:		if ((term->ws_col = tgetnum("co")) < 0
srcs/cmdline/init_termcaps.c:			|| (term->ws_li = tgetnum("li")) < 0)
srcs/cmdline/init_termcaps.c:	term->ws_col = size.ws_col;
srcs/cmdline/init_termcaps.c:	term->ws_li = size.ws_row;
srcs/cmdline/init_termcaps.c:	i = -1;
srcs/cmdline/init_termcaps.c:		if ((term->tcaps[i] = tgetstr(termcaps[i], NULL)) == NULL)
srcs/cmdline/init_termcaps.c:	if (tgetent(NULL, ((sh) ? sh : "xterm-256color")) == 0)
srcs/cmdline/prompt/prompt.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/cmdline/prompt/prompt.c:/*   Updated: 2020/03/08 19:03:22 by mpivet-p         ###   ########.fr       */
srcs/cmdline/prompt/prompt.c:**	  - `up' => to move the cursor vertically up one input
srcs/cmdline/prompt/prompt.c:**	  - `cr' => to move the cursor to the beginning of the input it is on
srcs/cmdline/prompt/prompt.c:**	  - `clr_inputs' => to clear input from the cursor and following inputs
srcs/cmdline/prompt/prompt.c:	if ((int)ft_strlen(term->prompt) > term->ws_col)
srcs/cmdline/prompt/prompt.c:		term->y += ft_strlen(term->prompt) / term->ws_col;
srcs/cmdline/prompt/prompt.c:	while (term->y-- > 0)
srcs/cmdline/prompt/prompt.c:		xtputs(term->tcaps[KEY_UP], 1, my_outc);
srcs/cmdline/prompt/prompt.c:	xtputs(term->tcaps[LEFT_MARGIN], 1, my_outc);
srcs/cmdline/prompt/prompt.c:	xtputs(term->tcaps[CLR_LINES], 1, my_outc);
srcs/cmdline/prompt/prompt.c:	if (term->sub_prompt > 0)
srcs/cmdline/prompt/prompt.c:	term->prompt_len = ft_strlen(term->prompt);
srcs/cmdline/prompt/prompt.c:	term->prompt_len = term->prompt_len % term->ws_col;
srcs/cmdline/prompt/prompt.c:	term->x = term->prompt_len;
srcs/cmdline/prompt/prompt.c:	term->y = 0;
srcs/cmdline/prompt/prompt.c:	term->x_index = term->x;
srcs/cmdline/prompt/prompt.c:	term->width = term->x;
srcs/cmdline/prompt/prompt.c:	term->sub_prompt = 0;
srcs/cmdline/prompt/prompt.c:	ft_dprintf(STDERR_FILENO, "%s%s%s%s", C_BOLD, C_Y, term->prompt, C_X);
srcs/cmdline/prompt/prompt.c:	xtputs(term->tcaps[CLR_LINES], 1, my_outc);
srcs/cmdline/prompt/prompt.c:	if (!*(shell->term).buffer && get_mask(buff) == CTRL_D)
srcs/cmdline/prompt/prompt.c:		if (are_jobs_done(shell, shell->launched_jobs) != TRUE)
srcs/cmdline/prompt/prompt.c:			display_prompt(&(shell->term));
srcs/cmdline/prompt/prompt.c:	shell->term.status = CMD_PROMPT;
srcs/cmdline/prompt/prompt.c:	shell->term.buffer = ft_memalloc(BUFF_SIZE);
srcs/cmdline/prompt/prompt.c:	display_prompt(&shell->term);
srcs/cmdline/prompt/prompt.c:		if (check_caps(buff, &shell->term) == TRUE)
srcs/cmdline/prompt/prompt.c:		else if (*shell->term.prompt
srcs/cmdline/prompt/prompt.c:			|| (!*shell->term.prompt && shell->term.buffer))
srcs/cmdline/prompt/prompt.c:	shell->term.status = CMD_DONE;
srcs/cmdline/prompt/prompt.c:		check_expansions(&shell->term);
srcs/cmdline/sub_prompt/check_backslash.c:	while (term->buffer[i])
srcs/cmdline/sub_prompt/check_backslash.c:		if (term->buffer[i] == c)
srcs/cmdline/sub_prompt/check_backslash.c:		else if (c == BACKSLASH && count > 0 && term->buffer[i] != c)
srcs/cmdline/sub_prompt/check_backslash.c:	if (!*term->buffer)
srcs/cmdline/sub_prompt/check_backslash.c:	if (term->buffer[ft_strlen(term->buffer) - 1] == BACKSLASH)
srcs/cmdline/sub_prompt/check_subprompt.c:	i = -1;
srcs/cmdline/sub_prompt/check_subprompt.c:	while (term->buffer[++i] != '\0')
srcs/cmdline/sub_prompt/check_subprompt.c:		if (term->buffer[i] == BACKSLASH)
srcs/cmdline/sub_prompt/check_subprompt.c:		*quote = set_quote_type(term->buffer[i]);
srcs/cmdline/sub_prompt/check_subprompt.c:			if (goto_next_quote(term->buffer, *quote, &i) == TRUE)
srcs/cmdline/sub_prompt/check_subprompt.c:	if (quotes_is_matching(&shell->term, &quote) == TRUE
srcs/cmdline/sub_prompt/check_subprompt.c:		if (check_backslash(&shell->term, &quote) == FALSE)
srcs/cmdline/sub_prompt/check_subprompt.c:		shell->term.sub_prompt = TRUE;
srcs/cmdline/sub_prompt/check_subprompt.c:		ft_strdel(&shell->term.prompt);
srcs/cmdline/sub_prompt/check_subprompt.c:		shell->term.status = CMD_SUBPROMPT;
srcs/cmdline/sub_prompt/check_subprompt.c:		load_subprompt(quote, &shell->term);
srcs/cmdline/sub_prompt/heredoc.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/cmdline/sub_prompt/heredoc.c:/*   Updated: 2020/03/08 14:42:42 by mpivet-p         ###   ########.fr       */
srcs/cmdline/sub_prompt/heredoc.c:		"42sh: warning: here-document delimited by eof (wanted `%s')\n", key);
srcs/cmdline/sub_prompt/heredoc.c:	if (read_multiline(&shell->term, NULL) == FALSE)
srcs/cmdline/sub_prompt/heredoc.c:		if (shell->term.flag == TRUE)
srcs/cmdline/sub_prompt/heredoc.c:		if (ft_strcmp(shell->term.buffer, key))
srcs/cmdline/sub_prompt/heredoc.c:			shell->term.buffer = ft_strjoinf(shell->term.tmp_buff,
srcs/cmdline/sub_prompt/heredoc.c:														shell->term.buffer, 2);
srcs/cmdline/sub_prompt/heredoc.c:			shell->term.buffer = ft_strjoinf(shell->term.buffer, NEW_LINE, 1);
srcs/cmdline/sub_prompt/heredoc.c:			ft_strdel(&shell->term.tmp_buff);
srcs/cmdline/sub_prompt/heredoc.c:			shell->term.tmp_buff = ft_strdup(shell->term.buffer);
srcs/cmdline/sub_prompt/heredoc.c:	buffer = ft_strdup(shell->term.tmp_buff);
srcs/cmdline/sub_prompt/heredoc.c:	ft_strdel(&shell->term.tmp_buff);
srcs/cmdline/sub_prompt/heredoc.c:	shell->term.status = CMD_DONE;
srcs/cmdline/sub_prompt/heredoc.c:	value = ft_strsub(buffer, i + 1, ft_strlen(buffer) - i);
srcs/cmdline/sub_prompt/heredoc.c:	ft_strdel(&shell->term.buffer);
srcs/cmdline/sub_prompt/heredoc.c:	shell->term.buffer = ft_strsub(buffer, 0, i);
srcs/cmdline/sub_prompt/heredoc.c:	shell->heredoc = 1;
srcs/cmdline/sub_prompt/heredoc.c:	shell->term.buffer = ft_strjoinf(shell->term.buffer, NEW_LINE, 1);
srcs/cmdline/sub_prompt/heredoc.c:	shell->term.tmp_buff = ft_strdup(shell->term.buffer);
srcs/cmdline/sub_prompt/heredoc.c:	shell->term.status = CMD_SUBPROMPT;
srcs/cmdline/sub_prompt/heredoc.c:	while (TRUE && shell->term.status == CMD_SUBPROMPT)
srcs/cmdline/sub_prompt/heredoc.c:		ft_strdel(&shell->term.buffer);
srcs/cmdline/sub_prompt/heredoc.c:		shell->term.buffer = ft_memalloc(BUFF_SIZE);
srcs/cmdline/sub_prompt/heredoc.c:		display_subprompt(&shell->term);
srcs/cmdline/sub_prompt/heredoc.c:		else if (*shell->term.prompt
srcs/cmdline/sub_prompt/heredoc.c:			|| (!*shell->term.prompt && shell->term.buffer))
srcs/cmdline/sub_prompt/heredoc.c:		if (shell->term.status == CMD_PROMPT)
srcs/cmdline/sub_prompt/sub_prompt.c:/*   Updated: 2020/03/08 14:42:57 by mpivet-p         ###   ########.fr       */
srcs/cmdline/sub_prompt/sub_prompt.c:	if (term->status != CMD_SUBPROMPT)
srcs/cmdline/sub_prompt/sub_prompt.c:	else if (*sb != BACKSLASH && ft_strchr(term->buffer, *sb))
srcs/cmdline/sub_prompt/sub_prompt.c:		term->buffer = ft_strjoinf(term->buffer, NEW_LINE, 1);
srcs/cmdline/sub_prompt/sub_prompt.c:		term->buffer = ft_strjoinf(term->tmp_buff, term->buffer, 2);
srcs/cmdline/sub_prompt/sub_prompt.c:			term->buffer = ft_strjoinf(term->tmp_buff, term->buffer, 2);
srcs/cmdline/sub_prompt/sub_prompt.c:		term->buffer = ft_strjoinf(term->buffer, NEW_LINE, 1);
srcs/cmdline/sub_prompt/sub_prompt.c:		ft_strdel(&term->tmp_buff);
srcs/cmdline/sub_prompt/sub_prompt.c:		term->tmp_buff = ft_strdup(term->buffer);
srcs/cmdline/sub_prompt/sub_prompt.c:		term->buffer = ft_strjoinf(term->tmp_buff, term->buffer, 2);
srcs/cmdline/sub_prompt/sub_prompt.c:		term->buffer = ft_strjoinf(term->buffer, NEW_LINE, 1);
srcs/cmdline/sub_prompt/sub_prompt.c:	term->tmp_buff = ft_strdup(term->buffer);
srcs/cmdline/sub_prompt/sub_prompt.c:	term->flag = FALSE;
srcs/cmdline/sub_prompt/sub_prompt.c:		ft_strdel(&term->buffer);
srcs/cmdline/sub_prompt/sub_prompt.c:		term->buffer = ft_memalloc(BUFF_SIZE);
srcs/cmdline/sub_prompt/sub_prompt.c:			else if (*term->prompt
srcs/cmdline/sub_prompt/sub_prompt.c:				|| (!*term->prompt && term->buffer))
srcs/cmdline/sub_prompt/sub_prompt.c:		term->tmp_buff = ft_strjoinf(term->tmp_buff, term->buffer, 1);
srcs/cmdline/sub_prompt/sub_prompt.c:	ft_strdel(&term->tmp_buff);
srcs/cmdline/sub_prompt/sub_prompt.c:	term->status = CMD_DONE;
srcs/cmdline/sub_prompt/subprompt_tools.c:/*   Updated: 2020/03/08 14:43:41 by mpivet-p         ###   ########.fr       */
srcs/cmdline/sub_prompt/subprompt_tools.c:	term->prompt_len = ft_strlen(term->prompt);
srcs/cmdline/sub_prompt/subprompt_tools.c:	term->x = term->prompt_len;
srcs/cmdline/sub_prompt/subprompt_tools.c:	term->y = 0;
srcs/cmdline/sub_prompt/subprompt_tools.c:	term->width = term->x;
srcs/cmdline/sub_prompt/subprompt_tools.c:	term->x_index = term->x;
srcs/cmdline/sub_prompt/subprompt_tools.c:	ft_dprintf(STDERR_FILENO, term->prompt);
srcs/cmdline/sub_prompt/subprompt_tools.c:	if (term->flag == TRUE)
srcs/cmdline/sub_prompt/subprompt_tools.c:		term->status = CMD_DONE;
srcs/cmdline/sub_prompt/subprompt_tools.c:	if (term->status != CMD_SUBPROMPT)
srcs/cmdline/sub_prompt/subprompt_tools.c:		term->status = CMD_DONE;
srcs/cmdline/term_config.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/cmdline/term_config.c:/*   Updated: 2020/03/08 14:38:45 by mpivet-p         ###   ########.fr       */
srcs/cmdline/term_config.c:	term->history = NULL;
srcs/cmdline/term_config.c:	term->history_index = NULL;
srcs/cmdline/term_config.c:	term->shell = shell;
srcs/cmdline/term_config.c:	term->flag = 0;
srcs/cmdline/term_config.c:	term->sub_prompt = 0;
srcs/cmdline/term_config.c:	term->buffer = NULL;
srcs/cmdline/term_config.c:	term->tmp_buff = NULL;
srcs/cmdline/term_config.c:	term->cmd = NULL;
srcs/cmdline/term_config.c:	term->prompt = NULL;
srcs/cmdline/term_config.c:	shell->term.history = term->history;
srcs/cmdline/term_config.c:**	- ICANON enable non-canonical mode
srcs/cmdline/term_config.c:**	- ECHO disable echo input characters
srcs/cmdline/term_config.c:	if (init_termcaps(&(shell->term)) == FAILURE)
srcs/cmdline/term_config.c:	if (tcgetattr(STDIN_FILENO, &(shell->old_t)) == FAILURE)
srcs/cmdline/term_config.c:	shell->new_t = shell->old_t;
srcs/cmdline/term_config.c:	shell->new_t.c_lflag &= ~(ICANON | ECHO);
srcs/cmdline/term_config.c:	shell->new_t.c_cc[VMIN] = 1;
srcs/cmdline/term_config.c:	shell->new_t.c_cc[VTIME] = 0;
srcs/cmdline/term_config.c:	if (tcsetattr(STDIN_FILENO, TCSANOW, &(shell->new_t)) == FAILURE)
srcs/cmdline/term_config.c:	if (tcsetattr(STDIN_FILENO, TCSANOW, &(shell->new_t)) == FAILURE)
srcs/cmdline/term_config.c:	if (tcsetattr(STDIN_FILENO, TCSANOW, &(shell->old_t)) == FAILURE)
srcs/cmdline/term_config.c:	ft_strdel(&shell->term.tmp_buff);
srcs/cmdline/term_config.c:	ft_strdel(&shell->term.prompt);
srcs/cmdline/term_config.c:	shell->term.cmd = NULL;
srcs/cmdline/utils/get_var_value.c:	if ((db = search_db(shell->env, key)) == NULL)
srcs/cmdline/utils/get_var_value.c:		shell->term.prompt = ft_strnew(0);
srcs/cmdline/utils/get_var_value.c:	if (!ft_strcmp(db->value, PS1))
srcs/cmdline/utils/get_var_value.c:		shell->term.prompt = ft_strsub(db->value, 1, 10);
srcs/cmdline/utils/get_var_value.c:	else if (!ft_strcmp(db->value, PS2))
srcs/cmdline/utils/get_var_value.c:		shell->term.prompt = ft_strsub(db->value, 1, 2);
srcs/cmdline/utils/get_var_value.c:		shell->term.prompt = ft_strdup(db->value);
srcs/cmdline/utils/get_var_value.c:	if ((db = search_db(shell->env, "HOME")) == NULL)
srcs/cmdline/utils/get_var_value.c:	else if (!is_dir(db->value))
srcs/cmdline/utils/get_var_value.c:		path = ft_strjoin(db->value, "/");
srcs/cmdline/utils/utils.c:/*   Updated: 2020/03/08 14:39:01 by mpivet-p         ###   ########.fr       */
srcs/cmdline/utils/utils.c:		xtputs(term->tcaps[LEFT_MARGIN], 1, my_outc);
srcs/cmdline/utils/utils.c:		xtputs(term->tcaps[CLR_LINES], 1, my_outc);
srcs/cmdline/utils/utils.c:		ft_dprintf(STDERR_FILENO, "%s%s%s%s%s", C_BOLD, F_C, term->prompt,
srcs/cmdline/utils/utils.c:				C_X, term->buffer);
srcs/cmdline/utils/utils.c:	x = term->x;
srcs/cmdline/utils/utils.c:	buff_index = term->x_index - term->prompt_len;
srcs/cmdline/utils/utils.c:	if (term->buffer[buff_index - 1] == NEW_LINE[0])
srcs/cmdline/utils/utils.c:		buff_index--;
srcs/cmdline/utils/utils.c:	while (buff_index--)
srcs/cmdline/utils/utils.c:		if (term->buffer[buff_index] == NEW_LINE[0])
srcs/cmdline/utils/utils.c:		else if (x == 0 && !ft_strchr(term->buffer, NEW_LINE[0]))
srcs/cmdline/utils/utils.c:			return (term->ws_col - 1);
srcs/cmdline/utils/utils.c:		x--;
srcs/cmdline/utils/utils.c:	if (width > term->ws_col)
srcs/cmdline/utils/utils.c:		width -= term->ws_col;
srcs/cmdline/utils/utils.c:	if (term->y == 1)
srcs/cmdline/utils/utils.c:		width += term->prompt_len;
srcs/cmdline/utils/utils.c:	x = term->x;
srcs/cmdline/utils/utils.c:	buff_index = term->x_index - term->prompt_len;
srcs/cmdline/utils/utils.c:	while (term->buffer[buff_index])
srcs/cmdline/utils/utils.c:		if (term->buffer[buff_index] == NEW_LINE[0] || x == term->ws_col - 1)
srcs/cmdline/utils/utils.c:	width += term->x;
srcs/cmdline/utils/utils.c:		shift -= 8;
srcs/cmdline/utils/xfunctions.c:/*   Updated: 2020/03/08 14:39:24 by mpivet-p         ###   ########.fr       */
srcs/core/free_handler.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/core/free_handler.c:/*   Updated: 2020/03/08 14:44:05 by mpivet-p         ###   ########.fr       */
srcs/core/free_handler.c:		ft_strdel(&((t_db*)(db->content))->key);
srcs/core/free_handler.c:		ft_strdel(&((t_db*)(db->content))->value);
srcs/core/free_handler.c:		free(db->content);
srcs/core/free_handler.c:		db = db->next;
srcs/core/free_handler.c:	ft_strdel(&shell->term.buffer);
srcs/core/free_handler.c:	ft_freejoblist(&shell->job_list);
srcs/core/free_handler.c:	while (term && term->history)
srcs/core/free_handler.c:		free(term->history->content);
srcs/core/free_handler.c:		tmp = term->history;
srcs/core/free_handler.c:		term->history = term->history->next;
srcs/core/free_handler.c:	free_db(shell->env);
srcs/core/free_handler.c:	free_history(&shell->term);
srcs/core/free_handler.c:	free_hash_map(&shell->hash);
srcs/core/free_handler.c:		free(lst->content);
srcs/core/free_handler.c:		lst = lst->next;
srcs/core/init_shell.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/core/init_shell.c:/*   Updated: 2020/03/08 14:44:30 by mpivet-p         ###   ########.fr       */
srcs/core/init_shell.c:	while (tcgetpgrp(shell->terminal) != (shell->pgid = getpgrp()))
srcs/core/init_shell.c:		kill(-shell->pgid, SIGTTIN);
srcs/core/init_shell.c:	shell->pgid = getpid();
srcs/core/init_shell.c:	if (setpgid(shell->pgid, shell->pgid) < 0)
srcs/core/init_shell.c:	if (tcsetpgrp(shell->terminal, shell->pgid) != SUCCESS)
srcs/core/init_shell.c:	shell->build = (struct s_build){DATE, BUILDP + 1, BUILDR, BUILDV};
srcs/core/init_shell.c:	shell->hash.size = HASH_SIZE;
srcs/core/init_shell.c:	shell->terminal = STDIN_FILENO;
srcs/core/init_shell.c:	if (isatty(shell->terminal) == TRUE)
srcs/core/init_shell.c:		shell->is_interactive = TRUE;
srcs/core/init_shell.c:		shell->is_interactive = FALSE;
srcs/core/main.c:/*   Updated: 2020/03/02 19:37:53 by mpivet-p         ###   ########.fr       */
srcs/core/shell_loader.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/core/shell_loader.c:/*   Updated: 2020/03/11 18:58:30 by mpivet-p         ###   ########.fr       */
srcs/core/shell_loader.c:	while (ft_getnextline(STDIN_FILENO, &shell->term.buffer))
srcs/core/shell_loader.c:		while (shell->term.buffer[i])
srcs/core/shell_loader.c:			if (shell->term.buffer[i] < 0)
srcs/core/shell_loader.c:		ft_bzero(shell->term.buffer, ft_strlen(shell->term.buffer));
srcs/core/shell_loader.c:	quit_shell(shell, shell->status, FALSE);
srcs/core/shell_loader.c:	init_cmd_line(shell, &shell->term);
srcs/core/shell_loader.c:		do_job_notification(shell, shell->launched_jobs, TRUE);
srcs/core/shell_loader.c:		save_history(&shell->term);
srcs/db/db_tools.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/db/db_tools.c:/*   Created: 2019/09/25 18:21:41 by mpivet-p          #+#    #+#             */
srcs/db/db_tools.c:/*   Updated: 2020/03/05 00:24:05 by mpivet-p         ###   ########.fr       */
srcs/db/db_tools.c:		ft_strdel(&(db->value));
srcs/db/db_tools.c:		db->value = new_value;
srcs/db/db_tools.c:		db->type |= new_type;
srcs/db/db_tools.c:	db = search_db(shell->env, key);
srcs/db/db_tools.c:		ft_lstappend(&(shell->env),
srcs/db/db_tools.c:			ft_lstnew(fetch_db(&(shell->db), key, var_type), sizeof(t_db)));
srcs/db/db_tools.c:		db = search_db(shell->env, key);
srcs/db/db_tools.c:		db = (t_db*)env->content;
srcs/db/db_tools.c:		if (ft_strcmp(db->key, key) == 0)
srcs/db/db_tools.c:		env = env->next;
srcs/db/db_tools.c:	prev = shell->env;
srcs/db/db_tools.c:	env = shell->env;
srcs/db/db_tools.c:	while (env != NULL && ft_strcmp(key, ((t_db*)env->content)->key) != 0)
srcs/db/db_tools.c:		env = env->next;
srcs/db/db_tools.c:		prev->next = env->next;
srcs/db/db_tools.c:			shell->env = env->next;
srcs/db/db_tools.c:		ft_strdel(&(((t_db*)env->content)->key));
srcs/db/db_tools.c:		ft_strdel(&(((t_db*)env->content)->value));
srcs/db/db_tools.c:		ft_memdel(&env->content);
srcs/db/env_updates.c:/*   Created: 2019/09/15 19:12:06 by mpivet-p          #+#    #+#             */
srcs/db/env_updates.c:/*   Updated: 2020/03/08 14:45:33 by mpivet-p         ###   ########.fr       */
srcs/db/env_updates.c:		if (ft_atol(db->value, &value) != SUCCESS)
srcs/db/env_updates.c:			new_value = -1;
srcs/db/env_updates.c:		value = ft_strdup(argv[tablen - 1]);
srcs/db/env_updates.c:		value = ft_strdup(db_oldpwd->value);
srcs/db/fetch_db.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/db/fetch_db.c:/*   Updated: 2020/03/05 00:34:42 by mpivet-p         ###   ########.fr       */
srcs/db/fetch_db.c:	if (!(db->key = ft_strsub(s, 0, len)))
srcs/db/fetch_db.c:		if (!(db->value = ft_strsub(s, len + 1, ft_strlen(s) - len)))
srcs/db/fetch_db.c:			ft_strdel(&(db->key));
srcs/db/fetch_db.c:	db->type = var_type;
srcs/db/get_opt.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/db/get_opt.c:/*   Updated: 2020/03/08 14:45:53 by mpivet-p         ###   ########.fr       */
srcs/db/get_opt.c:		ft_dprintf(fd, "42sh: -%c: invalid option\n", option);
srcs/db/get_opt.c:	ft_dprintf(fd, "Shell options:\n\t-vh or -c command\n");
srcs/db/get_opt.c:		shell->build.release, shell->build.version, shell->build.patch);
srcs/db/get_opt.c:		shell->build.release, shell->build.version, shell->build.patch);
srcs/db/get_opt.c:		ft_dprintf(STDERR_FILENO, "42sh: -c: option requires an argument\n");
srcs/db/get_opt.c:	shell->is_interactive = FALSE;
srcs/db/get_opt.c:	shell->term.buffer = ft_strdup(av[2]);
srcs/db/get_opt.c:	if (opt & (1ULL << ('h' - 97)))
srcs/db/get_opt.c:	if (opt & (1ULL << ('v' - 97)))
srcs/db/get_opt.c:	if (opt & (1ULL << ('c' - 97)))
srcs/db/history.c:/*   Updated: 2020/03/08 15:14:14 by mpivet-p         ###   ########.fr       */
srcs/db/history.c:**		- Should only be executed at shell startup
srcs/db/history.c:**		- Should only be executed at shell startup
srcs/db/history.c:**		- Should only be executed at shell startup
srcs/db/process_vars.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/db/process_vars.c:/*   Created: 2020/01/15 16:51:00 by mpivet-p          #+#    #+#             */
srcs/db/process_vars.c:/*   Updated: 2020/03/08 15:14:31 by mpivet-p         ###   ########.fr       */
srcs/db/process_vars.c:**		- Should only be executed at shell startup
srcs/db/process_vars.c:	pid = -1;
srcs/db/process_vars.c:**		- Should be updated each time it changes
srcs/db/process_vars.c:	job = get_job(shell->launched_jobs, "%%");
srcs/db/process_vars.c:			value = ft_itoa(job->pgid);
srcs/db/set_env.c:/*   Updated: 2020/03/01 23:49:55 by mpivet-p         ###   ########.fr       */
srcs/db/set_env.c:**	- Create required variables (internals and env)
srcs/db/set_env.c:**	- Modify Inherited vars from the parent shell
srcs/db/set_env.c:		ft_lstappend(&shell->env, ft_lstnew(fetch_db(&shell->db
srcs/db/set_env.c:	if (search_db(shell->env, "OLDPWD") == NULL)
srcs/db/set_env.c:		fetch_db(&shell->db, "OLDPWD", EXPORT_VAR);
srcs/db/set_env.c:		ft_strdel(&(shell->db.value));
srcs/db/set_env.c:		ft_lstappend(&shell->env, ft_lstnew(&(shell->db), sizeof(t_db)));
srcs/db/set_updates.c:/*   Created: 2019/09/23 17:56:37 by mpivet-p          #+#    #+#             */
srcs/db/set_updates.c:**		- should only be executed at shell startup
srcs/db/set_updates.c:	if (search_db(shell->env, "TERM") == NULL)
srcs/db/set_updates.c:		if (ft_lstappend(&(shell->env), ft_lstnew(
srcs/db/set_updates.c:				fetch_db(&(shell->db), "TERM=dumb", INTERNAL_VAR)
srcs/db/set_updates.c:**		- Should be updated each time SIGWINCH is captured
srcs/db/set_updates.c:		if (!(value = ft_itoa(shell->term.ws_li))
srcs/db/set_updates.c:		if (!(value = ft_itoa(shell->term.ws_col))
srcs/db/special_vars.c:/*   By: mpivet-p <marvin@42.fr>                    +#+  +:+       +#+        */
srcs/db/special_vars.c:/*   Created: 2020/01/15 16:40:07 by mpivet-p          #+#    #+#             */
srcs/db/special_vars.c:/*   Updated: 2020/01/15 16:41:03 by mpivet-p         ###   ########.fr       */
srcs/db/special_vars.c:**		- Should be updated each time set is used to add positional vars.
srcs/db/special_vars.c:		value = ft_itoa(ft_lstlen(shell->pos_vars));
srcs/db/special_vars.c:**		- Should be exec. only one time at the shell startup.
srcs/db/special_vars.c:**	Update $- special variable, containing shell flags
srcs/db/special_vars.c:	if (shell && (db = get_or_create_db(shell, "-", SPECIAL_VAR)) != NULL)
srcs/db/special_vars.c:**		- initialized at shell startup and updated each time a pipeline exits
srcs/db/special_vars.c:		value = ft_itoa(shell->status);
srcs/db/version.c:/*   By: mpivet-p <marvin@42.fr>                    +#+  +:+       +#+        */
srcs/db/version.c:/*   Created: 2019/09/25 01:59:58 by mpivet-p          #+#    #+#             */
srcs/db/version.c:/*   Updated: 2020/01/15 16:43:18 by mpivet-p         ###   ########.fr       */
srcs/db/version.c:**		- Should only be executed at shell startup
srcs/db/version.c:	ft_itoabuf(shell->build.release, version);
srcs/db/version.c:	ft_itoabuf(shell->build.version, version);
srcs/db/version.c:	ft_itoabuf(shell->build.patch, version);
srcs/db/version.c:	ft_strcat(version, "-dev'");
srcs/exec/call_bin.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/exec/call_bin.c:/*   Created: 2019/11/05 01:58:53 by mpivet-p          #+#    #+#             */
srcs/exec/call_bin.c:/*   Updated: 2020/03/08 15:15:31 by mpivet-p         ###   ########.fr       */
srcs/exec/call_bin.c:	if (process->av == NULL)
srcs/exec/call_bin.c:	if (process->bin == NULL)
srcs/exec/call_bin.c:			"42sh: %s: command not found\n", process->av[0]);
srcs/exec/call_bin.c:	else if ((ret = ft_access(process->bin, F_OK | X_OK)) != SUCCESS)
srcs/exec/call_bin.c:		ft_perror(process->bin, NULL, ret);
srcs/exec/call_bin.c:	else if (is_dir(process->bin))
srcs/exec/call_bin.c:		ft_perror(process->av[0], NULL, EISDIR);
srcs/exec/call_bin.c:	if (exec_redirs(shell, process, process->redir_list) != SUCCESS)
srcs/exec/call_bin.c:	if (process->av && (blt = is_a_blt(process->av[0])) != FAILURE)
srcs/exec/call_bin.c:		shell->is_interactive = FALSE;
srcs/exec/call_bin.c:	if (process->bin == NULL)
srcs/exec/call_bin.c:		if (process->av != NULL)
srcs/exec/call_bin.c:				, "42sh: %s: command not found\n", process->av[0]);
srcs/exec/call_bin.c:		ret = execve(process->bin, process->av, process->envp);
srcs/exec/call_builtin.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/exec/call_builtin.c:/*   Created: 2019/09/30 00:24:24 by mpivet-p          #+#    #+#             */
srcs/exec/call_builtin.c:/*   Updated: 2020/02/13 20:49:43 by mpivet-p         ###   ########.fr       */
srcs/exec/dispatcher.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/exec/dispatcher.c:/*   Created: 2019/11/01 16:54:22 by mpivet-p          #+#    #+#             */
srcs/exec/dispatcher.c:/*   Updated: 2020/03/11 20:36:07 by mpivet-p         ###   ########.fr       */
srcs/exec/dispatcher.c:	if (process->type == P_PIPE)
srcs/exec/dispatcher.c:		next = ptr->content;
srcs/exec/dispatcher.c:		process->pipe[1] = pipes[1];
srcs/exec/dispatcher.c:		process->close[1] = pipes[0];
srcs/exec/dispatcher.c:		next->pipe[0] = pipes[0];
srcs/exec/dispatcher.c:		next->close[0] = pipes[1];
srcs/exec/dispatcher.c:	if (WIFSTOPPED(process->status))
srcs/exec/dispatcher.c:		return (WSTOPSIG(process->status));
srcs/exec/dispatcher.c:	else if (WIFSIGNALED(process->status))
srcs/exec/dispatcher.c:		return (WTERMSIG(process->status));
srcs/exec/dispatcher.c:	ptr = ((t_process *)process->content);
srcs/exec/dispatcher.c:	cond = ptr->type;
srcs/exec/dispatcher.c:	&& get_signal(ptr) == 0 && WEXITSTATUS(ptr->status) == 0)
srcs/exec/dispatcher.c:	&& (get_signal(ptr) != 0 || WEXITSTATUS(ptr->status) != 0))
srcs/exec/dispatcher.c:	while (process && (ptr = ((t_process *)process->content))
srcs/exec/dispatcher.c:	&& (ptr->type == (enum e_pstate)cond || ptr->type == P_PIPE))
srcs/exec/dispatcher.c:		((t_process *)process->next->content)->completed = TRUE;
srcs/exec/dispatcher.c:		process = process->next;
srcs/exec/dispatcher.c:	process = job->process_list;
srcs/exec/dispatcher.c:	while (process && (ptr = ((t_process *)process->content)))
srcs/exec/dispatcher.c:		ptr->stopped = (foreground == TRUE) ? FALSE : TRUE;
srcs/exec/dispatcher.c:		if (ptr->completed == FALSE)
srcs/exec/dispatcher.c:			setup_pipes(ptr, process->next);
srcs/exec/dispatcher.c:			if (ptr->completed == FALSE)
srcs/exec/dispatcher.c:				if (ptr->completed == FALSE)
srcs/exec/dispatcher.c:		process = process->next;
srcs/exec/exec_process.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/exec/exec_process.c:/*   Updated: 2020/03/11 18:12:52 by mpivet-p         ###   ########.fr       */
srcs/exec/exec_process.c:	ptr = job->process_list;
srcs/exec/exec_process.c:	while (ptr != NULL && ptr->content != process)
srcs/exec/exec_process.c:		if (((t_process *)ptr->content)->completed != TRUE)
srcs/exec/exec_process.c:		ptr = ptr->next;
srcs/exec/exec_process.c:	if (process->pgid == -1)
srcs/exec/exec_process.c:		job->pgid = process->pid;
srcs/exec/exec_process.c:	process->pgid = job->pgid;
srcs/exec/exec_process.c:	if (setpgid(process->pid, process->pgid) != SUCCESS)
srcs/exec/exec_process.c:	if (process->stopped != TRUE && process->type != P_PIPE)
srcs/exec/exec_process.c:		if (tcsetpgrp(shell->terminal, process->pgid) != SUCCESS)
srcs/exec/exec_process.c:		if (process->pipe[0] != STDIN_FILENO)
srcs/exec/exec_process.c:			wait_for_job(shell, shell->job_list, job);
srcs/exec/exec_process.c:			wait_for_process(shell, shell->job_list, process);
srcs/exec/exec_process.c:		if (tcsetpgrp(shell->terminal, shell->pgid) != SUCCESS)
srcs/exec/exec_process.c:		process->stopped = FALSE;
srcs/exec/exec_process.c:		job->pgid = -1;
srcs/exec/exec_process.c:	process->pgid = job->pgid;
srcs/exec/exec_process.c:	if (process->av)
srcs/exec/exec_process.c:	if ((process->pid = fork()) == 0)
srcs/exec/exec_process.c:	else if (process->pid < 0)
srcs/exec/exec_process.c:	if (process->pipe[1] != STDOUT_FILENO)
srcs/exec/exec_process.c:		close(process->pipe[1]);
srcs/exec/exec_process.c:	if (process->pipe[0] != STDIN_FILENO)
srcs/exec/exec_process.c:		close(process->pipe[0]);
srcs/exec/exec_process.c:	if (shell->is_interactive == TRUE)
srcs/exec/exec_process.c:	else if (process->type != P_PIPE)
srcs/exec/exec_process.c:		wait_for_process(shell, shell->job_list, process);
srcs/exec/get_bin.c:/*   Updated: 2020/03/08 15:17:25 by mpivet-p         ###   ########.fr       */
srcs/exec/get_bin.c:	if (i > 0 && path[i - 1] == '/')
srcs/exec/get_bin.c:		if ((process->bin = ft_strjoin(path, process->av[0])) == NULL)
srcs/exec/get_bin.c:	if (!(tmp = ft_strjoin("/", process->av[0])))
srcs/exec/get_bin.c:	process->bin = ft_strjoin(path, tmp);
srcs/exec/get_bin.c:	return ((process->bin == NULL) ? FAILURE : SUCCESS);
srcs/exec/get_bin.c:	if (check_filepath(process->bin) == SUCCESS)
srcs/exec/get_bin.c:	if (access(process->bin, F_OK) != 0)
srcs/exec/get_bin.c:		ft_strdel(&process->bin);
srcs/exec/get_bin.c:	i = -1;
srcs/exec/get_bin.c:	if ((db = search_db(shell->env, "PATH")) == NULL)
srcs/exec/get_bin.c:		return ((process->blt || (process->bin = ft_strdup(
srcs/exec/get_bin.c:							process->av[0])) >= 0) ? FAILURE : SUCCESS);
srcs/exec/get_bin.c:	if (!(split_path = ft_strsplit(db->value, ":")))
srcs/exec/get_bin.c:		ft_strdel(&(process->bin));
srcs/exec/get_bin.c:	if (process->av[0][0] == 0)
srcs/exec/get_bin.c:		process->bin = NULL;
srcs/exec/get_bin.c:	if ((process->av[0][0] == '.'
srcs/exec/get_bin.c:			&& process->av[0][1] == '/'
srcs/exec/get_bin.c:			&& process->av[0][2] != 0)
srcs/exec/get_bin.c:		|| (process->av[0][0] == '/'
srcs/exec/get_bin.c:			&& process->av[0][1]))
srcs/exec/get_bin.c:		process->bin = ft_strdup(process->av[0]);
srcs/exec/get_bin.c:	if (!process->blt)
srcs/exec/redirections/exec_redirs.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/exec/redirections/exec_redirs.c:/*   Created: 2019/11/07 03:31:01 by mpivet-p          #+#    #+#             */
srcs/exec/redirections/exec_redirs.c:/*   Updated: 2020/03/08 15:28:35 by mpivet-p         ###   ########.fr       */
srcs/exec/redirections/exec_redirs.c:	ptr->io_num[0] = -1;
srcs/exec/redirections/exec_redirs.c:	ptr->io_num[1] = -1;
srcs/exec/redirections/exec_redirs.c:	ptr->dup_fd[0] = -1;
srcs/exec/redirections/exec_redirs.c:	ptr->dup_fd[1] = -1;
srcs/exec/redirections/exec_redirs.c:	ptr->close = -1;
srcs/exec/redirections/exec_redirs.c:	if (ptr->op[0] && ft_strcmp(ptr->op[0], "&") != 0)
srcs/exec/redirections/exec_redirs.c:		ptr->io_num[0] = ft_atoi(ptr->op[0]);
srcs/exec/redirections/exec_redirs.c:	else if (ptr->op[0])
srcs/exec/redirections/exec_redirs.c:		ptr->io_num[0] = 1;
srcs/exec/redirections/exec_redirs.c:		ptr->io_num[1] = 2;
srcs/exec/redirections/exec_redirs.c:	if (!redir->op[1] || !*redir->op[1])
srcs/exec/redirections/exec_redirs.c:	if (redir->type == P_GREAT && redir_output(redir) != SUCCESS)
srcs/exec/redirections/exec_redirs.c:	if (redir->type == P_DGREAT && append_output(redir) != SUCCESS)
srcs/exec/redirections/exec_redirs.c:	if ((redir->type == P_LESS || redir->type == P_DLESS)
srcs/exec/redirections/exec_redirs.c:	if (redir->type == P_LESSAND && dup_ifd(redir) != SUCCESS)
srcs/exec/redirections/exec_redirs.c:	if (redir->type == P_GREATAND && dup_ofd(redir) != SUCCESS)
srcs/exec/redirections/exec_redirs.c:		if (((t_redir*)redirs->content)->type == P_DLESS)
srcs/exec/redirections/exec_redirs.c:			((t_redir*)redirs->content)->dup_fd[0] = shell->heredoc++;
srcs/exec/redirections/exec_redirs.c:		if (get_fd(((t_redir*)redirs->content)) != SUCCESS)
srcs/exec/redirections/exec_redirs.c:			process->status = 1;
srcs/exec/redirections/exec_redirs.c:			process->completed = TRUE;
srcs/exec/redirections/exec_redirs.c:		redirs = redirs->next;
srcs/exec/redirections/redirs.c:/*   Created: 2019/11/07 03:31:42 by mpivet-p          #+#    #+#             */
srcs/exec/redirections/redirs.c:	if (ptr->io_num[0] < 0)
srcs/exec/redirections/redirs.c:		ptr->io_num[0] = 1;
srcs/exec/redirections/redirs.c:	if ((fd = open(ptr->op[1], O_WRONLY | O_APPEND | O_CREAT
srcs/exec/redirections/redirs.c:		if (is_a_dir(ptr->op[1]) == EISDIR)
srcs/exec/redirections/redirs.c:			ft_perror(ptr->op[1], NULL, EISDIR);
srcs/exec/redirections/redirs.c:			ft_perror(ptr->op[1], NULL, ft_access(ptr->op[1], W_OK));
srcs/exec/redirections/redirs.c:	if (ptr->io_num[0] < 0)
srcs/exec/redirections/redirs.c:		ptr->io_num[0] = 1;
srcs/exec/redirections/redirs.c:	if ((fd = open(ptr->op[1], O_WRONLY | O_TRUNC | O_CREAT
srcs/exec/redirections/redirs.c:		if (is_a_dir(ptr->op[1]) == EISDIR)
srcs/exec/redirections/redirs.c:			ft_perror(ptr->op[1], NULL, EISDIR);
srcs/exec/redirections/redirs.c:			ft_perror(ptr->op[1], NULL, ft_access(ptr->op[1], W_OK));
srcs/exec/redirections/redirs.c:	if (ptr->io_num[0] < 0)
srcs/exec/redirections/redirs.c:		ptr->io_num[0] = 0;
srcs/exec/redirections/redirs.c:	if (ptr->type == P_DLESS && write_heredoc(ptr) != SUCCESS)
srcs/exec/redirections/redirs.c:	if ((fd = open(ptr->op[1], O_RDONLY)) < 0)
srcs/exec/redirections/redirs.c:		if (is_a_dir(ptr->op[1]) == EISDIR)
srcs/exec/redirections/redirs.c:			ft_perror(ptr->op[1], NULL, EISDIR);
srcs/exec/redirections/redirs.c:			ft_perror(ptr->op[1], NULL, ft_access(ptr->op[1], R_OK));
srcs/exec/redirections/redirs.c:	if (ptr->type == P_DLESS)
srcs/exec/redirections/redirs.c:		unlink(ptr->op[1]);
srcs/exec/redirections/redirs.c:	if (ptr->io_num[0] < 0)
srcs/exec/redirections/redirs.c:		ptr->io_num[0] = 0;
srcs/exec/redirections/redirs.c:	if (ft_strcmp(ptr->op[1], "-") == 0)
srcs/exec/redirections/redirs.c:		ptr->dup_fd[0] = dup(ptr->io_num[0]);
srcs/exec/redirections/redirs.c:		close(ptr->io_num[0]);
srcs/exec/redirections/redirs.c:	if (ft_is_number(ptr->op[1]) == SUCCESS)
srcs/exec/redirections/redirs.c:		ptr->dup_fd[0] = ft_atoi(ptr->op[1]);
srcs/exec/redirections/redirs.c:		if ((ptr->dup_fd[0] = dup2(ptr->dup_fd[0], ptr->io_num[0])) < 0)
srcs/exec/redirections/redirs.c:				STDERR_FILENO, "42sh: %s: Bad file descriptor\n", ptr->op[1]);
srcs/exec/redirections/redirs.c:	if (ptr->io_num[0] < 0)
srcs/exec/redirections/redirs.c:		ptr->io_num[0] = 1;
srcs/exec/redirections/redirs.c:	if (ft_strcmp(ptr->op[1], "-") == 0)
srcs/exec/redirections/redirs.c:		ptr->dup_fd[0] = dup(ptr->io_num[0]);
srcs/exec/redirections/redirs.c:		close(ptr->io_num[0]);
srcs/exec/redirections/redirs.c:	if (ft_is_number(ptr->op[1]) == SUCCESS)
srcs/exec/redirections/redirs.c:		if (fcntl(ft_atoi(ptr->op[1]), F_GETFD) != -1)
srcs/exec/redirections/redirs.c:			ptr->dup_fd[0] = dup(ptr->io_num[0]);
srcs/exec/redirections/redirs.c:			if ((dup2(ft_atoi(ptr->op[1]), ptr->io_num[0])) >= 0)
srcs/exec/redirections/redirs.c:			"42sh: %s: Bad file descriptor\n", ptr->op[1]);
srcs/exec/redirections/redirs_tools.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/exec/redirections/redirs_tools.c:/*   Created: 2019/11/07 03:29:40 by mpivet-p          #+#    #+#             */
srcs/exec/redirections/redirs_tools.c:/*   Updated: 2020/03/08 15:28:46 by mpivet-p         ###   ########.fr       */
srcs/exec/redirections/redirs_tools.c:	ptr->dup_fd[0] = dup(ptr->io_num[0]);
srcs/exec/redirections/redirs_tools.c:	tmp = dup2(fd, ptr->io_num[0]);
srcs/exec/redirections/redirs_tools.c:	ptr->close = fd;
srcs/exec/redirections/redirs_tools.c:	if (ptr->io_num[1] != -1 && tmp >= 0)
srcs/exec/redirections/redirs_tools.c:		ptr->dup_fd[1] = dup(ptr->io_num[1]);
srcs/exec/redirections/redirs_tools.c:		dup2(tmp, ptr->io_num[1]);
srcs/exec/redirections/redirs_tools.c:	if (tmp < 0 || ptr->dup_fd < 0)
srcs/exec/redirections/redirs_tools.c:		close_fds(redirs->next);
srcs/exec/redirections/redirs_tools.c:		ptr = ((t_redir*)redirs->content);
srcs/exec/redirections/redirs_tools.c:		if (ptr->dup_fd[0] >= 0)
srcs/exec/redirections/redirs_tools.c:			dup2(ptr->dup_fd[0], ptr->io_num[0]);
srcs/exec/redirections/redirs_tools.c:			close(ptr->dup_fd[0]);
srcs/exec/redirections/redirs_tools.c:		if (ptr->dup_fd[1] >= 0)
srcs/exec/redirections/redirs_tools.c:			dup2(ptr->dup_fd[1], ptr->io_num[1]);
srcs/exec/redirections/redirs_tools.c:			close(ptr->dup_fd[1]);
srcs/exec/redirections/redirs_tools.c:		if (ptr->close >= 0)
srcs/exec/redirections/redirs_tools.c:			close(ptr->close);
srcs/exec/redirections/redirs_tools.c:	ptr->dup_fd[0] = dup(ptr->io_num[0]);
srcs/exec/redirections/redirs_tools.c:	tmp = dup2(fd, ptr->io_num[0]);
srcs/exec/redirections/redirs_tools.c:	ptr->close = fd;
srcs/exec/redirections/redirs_tools.c:	ptr->op[1] = ft_strdup(filename);
srcs/exec/redirections/redirs_tools.c:	ft_putstr_fd(ptr->heredoc, fd);
srcs/exec/set_envp.c:/*   Updated: 2020/03/01 23:49:24 by mpivet-p         ###   ########.fr       */
srcs/exec/set_envp.c:**	Because we need to implement differents env. Like if we set env -i
srcs/exec/set_envp.c:		if (((t_db*)env->content)->type == (EXPORT_VAR | INTERNAL_VAR))
srcs/exec/set_envp.c:						ft_strjoin(((t_db*)(env->content))->key, "=")
srcs/exec/set_envp.c:						, ((t_db*)(env->content))->value, 1);
srcs/exec/set_envp.c:		env = env->next;
srcs/exec/set_envp.c:	i = ft_lstlen(shell->env);
srcs/exec/set_envp.c:	check_env(shell->env, envp, &i, TRUE);
srcs/exec/status_handler.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/exec/status_handler.c:/*   Created: 2019/11/19 20:31:06 by mpivet-p          #+#    #+#             */
srcs/exec/status_handler.c:/*   Updated: 2020/03/11 21:24:03 by mpivet-p         ###   ########.fr       */
srcs/exec/status_handler.c:	else if (process->type != P_PIPE)
srcs/exec/status_handler.c:	shell->status = status + 128;
srcs/exec/task_master.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/exec/task_master.c:/*   Created: 2019/11/05 19:19:07 by mpivet-p          #+#    #+#             */
srcs/exec/task_master.c:/*   Updated: 2020/03/10 16:01:44 by mpivet-p         ###   ########.fr       */
srcs/exec/task_master.c:	if (shell->is_interactive && job_is_completed(job))
srcs/exec/task_master.c:	if (!(shell->is_interactive))
srcs/exec/task_master.c:		wait_for_job(shell, shell->job_list, job);
srcs/exec/task_master.c:		put_job_in_foreground(shell, shell->job_list, job, FALSE);
srcs/exec/task_master.c:		job->jobc_id = update_jobs(shell->launched_jobs);
srcs/exec/task_master.c:		if (((t_process*)process->content)->type == P_ANDIF
srcs/exec/task_master.c:			|| ((t_process*)process->content)->type == P_ORIF)
srcs/exec/task_master.c:		process = process->next;
srcs/exec/task_master.c:	pid = -1;
srcs/exec/task_master.c:	if (foreground == FALSE && cond(job->process_list) && (pid = fork()) == 0)
srcs/exec/task_master.c:		shell->pgid = getpid();
srcs/exec/task_master.c:		job->pgid = shell->pgid;
srcs/exec/task_master.c:		shell->is_interactive = FALSE;
srcs/exec/task_master.c:		if (setpgid(shell->pgid, shell->pgid) < 0)
srcs/exec/task_master.c:		job->notified = TRUE;
srcs/exec/task_master.c:		job->pgid = pid;
srcs/exec/task_master.c:		shell->status = 0;
srcs/exec/task_master.c:	job = shell->job_list;
srcs/exec/task_master.c:		foreground = ((t_job*)job->content)->type == P_AND ? FALSE : TRUE;
srcs/exec/task_master.c:		next = job->next;
srcs/exec/task_master.c:		handle_background_job(shell, job->content, foreground);
srcs/exec/task_master.c:		place_job(shell, job->content, foreground);
srcs/exec/task_master.c:		if (job_is_completed(job->content))
srcs/exec/task_master.c:			free_job(&(shell->job_list), job);
srcs/exec/task_master.c:			shell->job_list = job->next;
srcs/exec/task_master.c:			job->next = NULL;
srcs/exec/task_master.c:			ft_lstappend(&(shell->launched_jobs), job);
srcs/exec/task_master.c:	shell->job_list = NULL;
srcs/exp/assign_envp_tools.c:/*   Updated: 2020/03/08 15:33:26 by mpivet-p         ###   ########.fr       */
srcs/exp/assign_envp_tools.c:	if (!key || !shell->env)
srcs/exp/assign_envp_tools.c:	i = -1;
srcs/exp/assign_envp_tools.c:	exp->index = 0;
srcs/exp/assign_envp_tools.c:	exp->discarded = 0;
srcs/exp/assign_envp_tools.c:	exp->res = ft_strnew(0);
srcs/exp/assign_envp_tools.c:	exp->st = E_START;
srcs/exp/assign_envp_tools.c:	exp->quotus = NB_EXPANSION_STATE;
srcs/exp/assign_envp_tools.c:	exp->sionat[0] = no_exp;
srcs/exp/assign_envp_tools.c:	exp->sionat[1] = exp_tilde;
srcs/exp/assign_envp_tools.c:	exp->sionat[2] = exp_tilde;
srcs/exp/assign_envp_tools.c:	exp->sionat[3] = exp_tilde;
srcs/exp/assign_envp_tools.c:	exp->sionat[4] = exp_math;
srcs/exp/assign_envp_tools.c:	exp->sionat[5] = exp_cmd_subs;
srcs/exp/assign_envp_tools.c:	exp->sionat[6] = exp_param;
srcs/exp/assign_envp_tools.c:	exp->sionat[7] = exp_math;
srcs/exp/assign_envp_tools.c:	exp->sionat[8] = exp_param;
srcs/exp/assign_envp_tools.c:	exp->biteurs[E_START] = start_biteurs;
srcs/exp/assign_envp_tools.c:	exp->biteurs[E_EXP] = exp_biteurs;
srcs/exp/assign_envp_tools.c:	exp->biteurs[E_WORD] = word_biteurs;
srcs/exp/assign_envp_tools.c:	exp->biteurs[E_QUOTES] = quotes_biteurs;
srcs/exp/assign_envp_tools.c:	exp->biteurs[E_DISCARD] = discard_biteurs;
srcs/exp/assign_envp_tools.c:	exp->erience = 0;
srcs/exp/expansion.c:/*   Updated: 2020/03/08 15:33:37 by mpivet-p         ###   ########.fr       */
srcs/exp/expansion.c:	if (!process->tok_list || !shell)
srcs/exp/expansion.c:	lst = process->tok_list;
srcs/exp/expansion.c:		if (((t_token*)lst->content)->data)
srcs/exp/expansion.c:			res = inhibiteurs_expansion(((t_token*)lst->content)->data, shell);
srcs/exp/expansion.c:				process->av = ft_add_arg_cmd_process(process->av, res);
srcs/exp/expansion.c:			else if (!*res && (ft_strchr(((t_token*)lst->content)->data, '\'')
srcs/exp/expansion.c:				|| ft_strchr(((t_token*)lst->content)->data, '\"')))
srcs/exp/expansion.c:				process->av = ft_add_arg_cmd_process(process->av, res);
srcs/exp/expansion.c:			if (!lst->next)
srcs/exp/expansion.c:				process->envp = add_underscore_envp(process->envp, res);
srcs/exp/expansion.c:		lst = lst->next;
srcs/exp/expansion.c:	if (!process->assign_list || !shell)
srcs/exp/expansion.c:	lst = process->assign_list;
srcs/exp/expansion.c:		if (((t_db*)lst->content)->value)
srcs/exp/expansion.c:			res = inhibiteurs_expansion(((t_token*)lst->content)->data, shell);
srcs/exp/expansion.c:			if (!process->av)
srcs/exp/expansion.c:				add_assign_env(shell, ((t_db*)lst->content)->key,
srcs/exp/expansion.c:				add_assign_envp(((t_db*)lst->content)->key,
srcs/exp/expansion.c:					ft_strdup(res), &process->envp);
srcs/exp/expansion.c:		lst = lst->next;
srcs/exp/expansion.c:	if (!redir || !redir->op[1])
srcs/exp/expansion.c:	if (redir->type != 8 && redir->type != 7
srcs/exp/expansion.c:		&& (res = inhibiteurs_expansion(redir->op[1], shell)))
srcs/exp/expansion.c:				redir->op[1]);
srcs/exp/expansion.c:			shell->status = 1;
srcs/exp/expansion.c:		ft_strdel(&(redir->op[1]));
srcs/exp/expansion.c:		redir->op[1] = ft_strdup(res);
srcs/exp/expansion.c:	if (shell->is_interactive && redir->heredoc
srcs/exp/expansion.c:		&& (res = inhibiteurs_expansion(redir->heredoc, shell)))
srcs/exp/expansion.c:		ft_strdel(&(redir->heredoc));
srcs/exp/expansion.c:		redir->heredoc = ft_strdup(res);
srcs/exp/expansion.c:	if (!process->redir_list || !shell)
srcs/exp/expansion.c:	lst = process->redir_list;
srcs/exp/expansion.c:		filename_heredoc_exp(shell, ((t_redir*)lst->content));
srcs/exp/expansion.c:		lst = lst->next;
srcs/exp/expansion.c:	process->envp = set_envp(shell);
srcs/exp/expansion.c:	if (process->tok_list)
srcs/exp/expansion.c:	if (process->assign_list)
srcs/exp/expansion.c:	if (process->redir_list)
srcs/exp/expansion.c:	if (!process->av)
srcs/exp/expansion.c:		process->status = 0;
srcs/exp/expansion.c:		shell->status = (!shell->status) ? 0 : 1;
srcs/exp/expansion.c:		process->completed = TRUE;
srcs/exp/lexer_exp/lexer_exp.c:		{E_TILDEM, "~-", 2},
srcs/exp/lexer_exp/lexer_param_cmds_exp.c:			*count -= 1;
srcs/exp/lexer_exp/lexer_param_cmds_exp.c:			|| str[1] == '!' || str[1] == '-'
srcs/exp/lexer_exp/lexer_tilde_math_exp.c:	return (ft_strdup("~-"));
srcs/exp/machine_expansion.c:	tmp[2] = ft_strsub(str, exp_size, len - exp_size);
srcs/exp/machine_expansion.c:	if ((res = exp->sionat[exp->erience](token, shell)))
srcs/exp/machine_expansion.c:		if ((exp->st == E_TILDEP || exp->st == E_TILDEM || exp->st == E_TILDE)
srcs/exp/machine_expansion.c:			&& !check_tilde_path_exp(res, data, exp->index, exp->st))
srcs/exp/machine_expansion.c:			exp->res = ft_strjoinf(exp->res, token, 1);
srcs/exp/machine_expansion.c:			exp->res = ft_strjoinf(exp->res, res, 4);
srcs/exp/machine_expansion.c:	exp->st = find_expansion(&data[exp->index]);
srcs/exp/machine_expansion.c:	exp->erience = is_expansion(exp->st);
srcs/exp/machine_expansion.c:	if ((exp_tok = get_expansion(&data[exp->index], exp->st)))
srcs/exp/machine_expansion.c:			exp->st = E_WORD;
srcs/exp/machine_expansion.c:		exp->index += ft_strlen(exp_tok);
srcs/exp/machine_expansion.c:	exp->st = (!data[exp->index]) ? E_END : E_START;
srcs/exp/machine_expansion.c:	if (!data[exp->index])
srcs/exp/machine_expansion.c:		exp->st = E_END;
srcs/exp/machine_expansion.c:	tmp = ft_strsub(data, exp->index, 1);
srcs/exp/machine_expansion.c:	exp->res = ft_strjoinf(exp->res, tmp, 4);
srcs/exp/machine_expansion.c:	exp->index++;
srcs/exp/machine_expansion.c:	exp->st = (!data[exp->index]) ? E_END : E_START;
srcs/exp/machine_expansion.c:	if (!data[exp->index])
srcs/exp/machine_expansion.c:		exp->st = E_END;
srcs/exp/machine_expansion.c:	else if (exp->quotus != E_QUOTE && data[exp->index] == '\\')
srcs/exp/machine_expansion.c:		exp->st = E_DISCARD;
srcs/exp/machine_expansion.c:	else if (!exp->discarded && quotes_condition(data[exp->index], exp->quotus)
srcs/exp/machine_expansion.c:		&& (data[exp->index] == '\'' || data[exp->index] == '\"'))
srcs/exp/machine_expansion.c:		exp->st = E_QUOTES;
srcs/exp/machine_expansion.c:	else if ((!exp->discarded && exp->quotus != E_QUOTE)
srcs/exp/machine_expansion.c:		&& ((data[exp->index] == '$' || data[exp->index] == '~'
srcs/exp/machine_expansion.c:			|| data[exp->index] == '`')))
srcs/exp/machine_expansion.c:		exp->st = E_EXP;
srcs/exp/machine_expansion.c:		exp->st = E_WORD;
srcs/exp/machine_expansion.c:	exp->discarded = 0;
srcs/exp/param_exp/error_param_format.c:/*   Updated: 2020/03/08 15:29:21 by mpivet-p         ###   ########.fr       */
srcs/exp/param_exp/error_param_format.c:	shell->status = 1;
srcs/exp/param_exp/error_param_format.c:	shell->status = 1;
srcs/exp/param_exp/error_param_format.c:	shell->status = 1;
srcs/exp/param_exp/error_param_format.c:	shell->status = 1;
srcs/exp/param_exp/param_exp.c:/*   Updated: 2020/03/08 15:29:03 by mpivet-p         ###   ########.fr       */
srcs/exp/param_exp/param_exp.c:	db = search_db(shell->env, key);
srcs/exp/param_exp/param_exp.c:		return (db->value);
srcs/exp/param_exp/param_exp.c:	shell->status = 1;
srcs/exp/param_exp/param_exp.c:		shell->status = 1;
srcs/exp/param_exp/param_exp.c:	if ((db_tmp = search_db(shell->env, &str[1])))
srcs/exp/param_exp/param_exp.c:		return (ft_itoa(ft_strlen(db_tmp->value)));
srcs/exp/param_exp/param_exp.c:		flag[1] = ft_strlen(tmp[1]) - 1;
srcs/exp/param_exp/param_expansion.c:/*   Updated: 2020/03/08 15:29:33 by mpivet-p         ###   ########.fr       */
srcs/exp/param_exp/param_expansion.c:	if ((db_tmp = search_db(shell->env, str)))
srcs/exp/param_exp/param_expansion.c:		return (ft_strdup(db_tmp->value));
srcs/exp/param_exp/param_expansion.c:	if (!(tmp = ft_strsub(str, 2, i - 2)))
srcs/exp/param_exp/param_expansion.c:		tmp = ft_strsub(data, 1, ft_strlen(data) - 1);
srcs/exp/param_exp/prefix_suffixe_format.c:/*   Updated: 2020/03/03 11:24:38 by mpivet-p         ###   ########.fr       */
srcs/exp/param_exp/prefix_suffixe_format.c:		pattern_size = ft_strlen(value) - ft_strlen(pattern);
srcs/exp/param_exp/prefix_suffixe_format.c:		return (ft_strsub(value, size, ft_strlen(value) - size));
srcs/exp/param_exp/two_point_param.c:/*   Updated: 2020/03/02 15:41:02 by mpivet-p         ###   ########.fr       */
srcs/exp/param_exp/two_point_param.c:	if (data[ft_strlen(data) - 1] == ':')
srcs/exp/param_exp/two_point_param.c:	if (tablo[1][0] == '-')
srcs/exp/quotes_backslash.c:	if (str[exp->index] == '\"'
srcs/exp/quotes_backslash.c:		&& (exp->quotus == E_DBQUOTE || exp->quotus == NB_EXPANSION_STATE))
srcs/exp/quotes_backslash.c:		if (exp->quotus == E_DBQUOTE)
srcs/exp/quotes_backslash.c:			exp->quotus = NB_EXPANSION_STATE;
srcs/exp/quotes_backslash.c:		else if (exp->quotus == NB_EXPANSION_STATE)
srcs/exp/quotes_backslash.c:			exp->quotus = E_DBQUOTE;
srcs/exp/quotes_backslash.c:		if (str[exp->index] == '\"')
srcs/exp/quotes_backslash.c:			exp->index += 1;
srcs/exp/quotes_backslash.c:	else if (str[exp->index] == '\''
srcs/exp/quotes_backslash.c:		&& (exp->quotus == E_QUOTE || exp->quotus == NB_EXPANSION_STATE))
srcs/exp/quotes_backslash.c:		if (exp->quotus == E_QUOTE)
srcs/exp/quotes_backslash.c:			exp->quotus = NB_EXPANSION_STATE;
srcs/exp/quotes_backslash.c:		else if (exp->quotus == NB_EXPANSION_STATE)
srcs/exp/quotes_backslash.c:			exp->quotus = E_QUOTE;
srcs/exp/quotes_backslash.c:		if (str[exp->index] == '\'')
srcs/exp/quotes_backslash.c:			exp->index += 1;
srcs/exp/quotes_backslash.c:	return (exp->quotus);
srcs/exp/quotes_backslash.c:		tmp = ft_strsub(data, index - backslash_nbr, backslash_nbr);
srcs/exp/quotes_backslash.c:	exp->quotus = skip_quotes(data, exp);
srcs/exp/quotes_backslash.c:	exp->st = (!data[exp->index]) ? E_END : E_START;
srcs/exp/quotes_backslash.c:	exp->discarded = discard_backslash(dt, &(exp->index), &(exp->res));
srcs/exp/quotes_backslash.c:	exp->st = (!dt[exp->index]) ? E_END : E_START;
srcs/exp/tilde_cmds_math_exp.c:	else if (data[0] == '~' && data[1] && data[1] == '-')
srcs/exp/tilde_cmds_math_exp.c:	if ((db_tmp = search_db(shell->env, path[i])))
srcs/exp/tilde_cmds_math_exp.c:		return (ft_strdup(db_tmp->value));
srcs/jobcontrol/are_jobs_done.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/jobcontrol/are_jobs_done.c:/*   Created: 2020/02/18 18:31:48 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/are_jobs_done.c:/*   Updated: 2020/02/19 02:56:17 by mpivet-p         ###   ########.fr       */
srcs/jobcontrol/are_jobs_done.c:	if (shell->notified != TRUE)
srcs/jobcontrol/are_jobs_done.c:		shell->notified = TRUE;
srcs/jobcontrol/are_jobs_done.c:			job = jobs->content;
srcs/jobcontrol/are_jobs_done.c:			jobs = jobs->next;
srcs/jobcontrol/background.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/jobcontrol/background.c:/*   Created: 2019/12/21 18:45:14 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/background.c:/*   Updated: 2020/02/21 02:41:22 by mpivet-p         ###   ########.fr       */
srcs/jobcontrol/background.c:	job->jobc_last = '+';
srcs/jobcontrol/background.c:	if (cont && kill(-1 * job->pgid, SIGCONT) < 0)
srcs/jobcontrol/continue.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/jobcontrol/continue.c:/*   Created: 2019/12/26 15:51:08 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/continue.c:/*   Updated: 2020/03/05 21:11:04 by mpivet-p         ###   ########.fr       */
srcs/jobcontrol/continue.c:		put_job_in_foreground(shell, shell->launched_jobs, job, TRUE);
srcs/jobcontrol/continue.c:		ptr = shell->launched_jobs;
srcs/jobcontrol/continue.c:		while (ptr && ptr->content != job)
srcs/jobcontrol/continue.c:			ptr = ptr->next;
srcs/jobcontrol/continue.c:		free_job(&(shell->launched_jobs), ptr);
srcs/jobcontrol/foreground.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/jobcontrol/foreground.c:/*   Created: 2019/12/21 18:01:39 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/foreground.c:/*   Updated: 2020/03/08 15:33:51 by mpivet-p         ###   ########.fr       */
srcs/jobcontrol/foreground.c:	if (tcsetpgrp(shell->terminal, job->pgid) != SUCCESS)
srcs/jobcontrol/foreground.c:		if (kill(-1 * job->pgid, SIGCONT) < 0)
srcs/jobcontrol/foreground.c:	if (tcsetpgrp(shell->terminal, shell->pgid) != SUCCESS)
srcs/jobcontrol/free_job_from_list.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/jobcontrol/free_job_from_list.c:/*   Created: 2020/03/08 13:24:57 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/free_job_from_list.c:/*   Updated: 2020/03/08 15:35:29 by mpivet-p         ###   ########.fr       */
srcs/jobcontrol/free_job_from_list.c:		while (ptr && ptr->next != job)
srcs/jobcontrol/free_job_from_list.c:			ptr = ptr->next;
srcs/jobcontrol/free_job_from_list.c:			ptr->next = job->next;
srcs/jobcontrol/free_job_from_list.c:		*job_list = job->next;
srcs/jobcontrol/free_job_from_list.c:		free_process_list(&(((t_job*)job->content)->process_list));
srcs/jobcontrol/free_job_from_list.c:		ft_strdel(&(((t_job*)job->content)->command));
srcs/jobcontrol/free_job_from_list.c:		free(job->content);
srcs/jobcontrol/get_job.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/jobcontrol/get_job.c:/*   Created: 2020/01/13 19:25:06 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/get_job.c:/*   Updated: 2020/02/16 21:21:51 by mpivet-p         ###   ########.fr       */
srcs/jobcontrol/get_job.c:		if (jobs->next == NULL)
srcs/jobcontrol/get_job.c:			return (jobs->content);
srcs/jobcontrol/get_job.c:		jobs = jobs->next;
srcs/jobcontrol/get_job.c:		ptr = jobs->content;
srcs/jobcontrol/get_job.c:		if (ptr->jobc_id == id)
srcs/jobcontrol/get_job.c:		jobs = jobs->next;
srcs/jobcontrol/get_job.c:		ptr = jobs->content;
srcs/jobcontrol/get_job.c:		while (str[i] == ptr->command[i])
srcs/jobcontrol/get_job.c:		jobs = jobs->next;
srcs/jobcontrol/job_utils.c:/*   Created: 2019/12/21 16:42:37 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/job_utils.c:		process = ((t_job*)job->content)->process_list;
srcs/jobcontrol/job_utils.c:			if (((t_process*)process->content)->pid == pid)
srcs/jobcontrol/job_utils.c:				return (((t_process*)process->content));
srcs/jobcontrol/job_utils.c:			process = process->next;
srcs/jobcontrol/job_utils.c:		job = job->next;
srcs/jobcontrol/job_utils.c:	ptr = job->process_list;
srcs/jobcontrol/job_utils.c:		if (((t_process*)ptr->content)->completed != TRUE
srcs/jobcontrol/job_utils.c:				&& ((t_process*)ptr->content)->stopped != TRUE)
srcs/jobcontrol/job_utils.c:		ptr = ptr->next;
srcs/jobcontrol/job_utils.c:	ptr = job->process_list;
srcs/jobcontrol/job_utils.c:		if (((t_process*)ptr->content)->completed != TRUE)
srcs/jobcontrol/job_utils.c:		ptr = ptr->next;
srcs/jobcontrol/jobc_id.c:/*   By: mpivet-p <marvin@42.fr>                    +#+  +:+       +#+        */
srcs/jobcontrol/jobc_id.c:/*   Created: 2020/01/19 20:07:37 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/jobc_id.c:/*   Updated: 2020/01/19 23:08:46 by mpivet-p         ###   ########.fr       */
srcs/jobcontrol/jobc_id.c:	jobs = shell->launched_jobs;
srcs/jobcontrol/jobc_id.c:		ptr = ((t_job*)jobs->content);
srcs/jobcontrol/jobc_id.c:		if (ptr != job && ptr->jobc_id > c)
srcs/jobcontrol/jobc_id.c:			c = ptr->jobc_id;
srcs/jobcontrol/jobc_id.c:		ptr->jobc_last = (ptr->jobc_last == '+') ? '-' : ' ';
srcs/jobcontrol/jobc_id.c:		jobs = jobs->next;
srcs/jobcontrol/jobc_id.c:	job->jobc_id = c + 1;
srcs/jobcontrol/jobc_id.c:	job->jobc_last = '+';
srcs/jobcontrol/jobc_id.c:	job->jobc_last = '+';
srcs/jobcontrol/jobc_id.c:	return (job->jobc_id);
srcs/jobcontrol/jobc_id.c:	if (!(job = get_job_by_id(jobs, (plus_id == max_id) ? max_id - 1 : max_id)))
srcs/jobcontrol/jobc_id.c:	job->jobc_last = '-';
srcs/jobcontrol/jobc_id.c:		job = ((t_job*)ptr->content);
srcs/jobcontrol/jobc_id.c:		c = (c < job->jobc_id) ? job->jobc_id : c;
srcs/jobcontrol/jobc_id.c:		plus = (job->jobc_last == '+') ? job->jobc_id : plus;
srcs/jobcontrol/jobc_id.c:		less = (job->jobc_last == '-') ? job->jobc_id : less;
srcs/jobcontrol/jobc_id.c:		ptr = ptr->next;
srcs/jobcontrol/launch_process.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/jobcontrol/launch_process.c:/*   Created: 2019/12/22 12:55:51 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/launch_process.c:/*   Updated: 2020/03/08 15:34:51 by mpivet-p         ###   ########.fr       */
srcs/jobcontrol/launch_process.c:	process->pid = getpid();
srcs/jobcontrol/launch_process.c:	if (process->pgid == -1)
srcs/jobcontrol/launch_process.c:		process->pgid = process->pid;
srcs/jobcontrol/launch_process.c:	if (setpgid(process->pid, process->pgid) != SUCCESS)
srcs/jobcontrol/launch_process.c:	if (process->pipe[0] != STDIN_FILENO)
srcs/jobcontrol/launch_process.c:		dup2(process->pipe[0], STDIN_FILENO);
srcs/jobcontrol/launch_process.c:		close(process->pipe[0]);
srcs/jobcontrol/launch_process.c:	if (process->pipe[1] != STDOUT_FILENO)
srcs/jobcontrol/launch_process.c:		dup2(process->pipe[1], STDOUT_FILENO);
srcs/jobcontrol/launch_process.c:		close(process->pipe[1]);
srcs/jobcontrol/launch_process.c:	if (process->close[0] != -1)
srcs/jobcontrol/launch_process.c:		close(process->close[0]);
srcs/jobcontrol/launch_process.c:	if (process->close[1] != -1)
srcs/jobcontrol/launch_process.c:		close(process->close[1]);
srcs/jobcontrol/launch_process.c:	if (process->pipe[0] == STDIN_FILENO && process->pipe[1] == STDOUT_FILENO
srcs/jobcontrol/launch_process.c:		&& process->av && (blt = is_a_blt(process->av[0])) != FAILURE)
srcs/jobcontrol/launch_process.c:		process->status = 1;
srcs/jobcontrol/launch_process.c:		if (exec_redirs(shell, process, process->redir_list) == SUCCESS)
srcs/jobcontrol/launch_process.c:			process->status = call_builtin(shell, process, blt);
srcs/jobcontrol/launch_process.c:		process->completed = TRUE;
srcs/jobcontrol/launch_process.c:		shell->status = process->status;
srcs/jobcontrol/launch_process.c:		close_fds(process->redir_list);
srcs/jobcontrol/launch_process.c:	if (shell->is_interactive)
srcs/jobcontrol/mark_job_as_stopped.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/jobcontrol/mark_job_as_stopped.c:/*   Created: 2020/02/08 04:04:30 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/mark_job_as_stopped.c:/*   Updated: 2020/03/05 17:02:55 by mpivet-p         ###   ########.fr       */
srcs/jobcontrol/mark_job_as_stopped.c:	ptr = job->process_list;
srcs/jobcontrol/mark_job_as_stopped.c:		((t_process*)ptr->content)->stopped = stopped;
srcs/jobcontrol/mark_job_as_stopped.c:		ptr = ptr->next;
srcs/jobcontrol/mark_process_status.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/jobcontrol/mark_process_status.c:/*   Created: 2020/01/17 22:32:48 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/mark_process_status.c:/*   Updated: 2020/03/11 20:53:58 by mpivet-p         ###   ########.fr       */
srcs/jobcontrol/mark_process_status.c:	if (pid > 0 && (process = find_process(jobs, pid)) && process->pid == pid)
srcs/jobcontrol/mark_process_status.c:		process->status = status;
srcs/jobcontrol/mark_process_status.c:			process->stopped = TRUE;
srcs/jobcontrol/mark_process_status.c:			process->completed = TRUE;
srcs/jobcontrol/notifications.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/jobcontrol/notifications.c:/*   Created: 2019/12/26 13:17:48 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/notifications.c:/*   Updated: 2020/03/11 18:52:32 by mpivet-p         ###   ########.fr       */
srcs/jobcontrol/notifications.c:	if (!shell->launched_jobs)
srcs/jobcontrol/notifications.c:	while (mark_process_status(shell, shell->launched_jobs, pid, status))
srcs/jobcontrol/notifications.c:	ft_dprintf(STDERR_FILENO, "[%i]%c  %s\t\t%s\n", job->jobc_id, job->jobc_last
srcs/jobcontrol/notifications.c:		? "Stopped" : signal_msg(signal), job->command);
srcs/jobcontrol/notifications.c:	ft_printf("[%i] %i\n", job->jobc_id, job->pgid);
srcs/jobcontrol/notifications.c:		ptr = ((t_job*)job->content);
srcs/jobcontrol/notifications.c:				free_job(&(shell->launched_jobs), job);
srcs/jobcontrol/notifications.c:			job = shell->launched_jobs;
srcs/jobcontrol/notifications.c:		else if (job_is_stopped(ptr) && ptr->notified != TRUE)
srcs/jobcontrol/notifications.c:			ptr->notified = TRUE;
srcs/jobcontrol/notifications.c:		job = job->next;
srcs/jobcontrol/wait_job.c:/*   By: mpivet-p <mpivet-p@student.42.fr>          +#+  +:+       +#+        */
srcs/jobcontrol/wait_job.c:/*   Created: 2019/12/27 20:36:16 by mpivet-p          #+#    #+#             */
srcs/jobcontrol/wait_job.c:/*   Updated: 2020/03/11 19:35:18 by mpivet-p         ###   ########.fr       */
srcs/jobcontrol/wait_job.c:	do_job_notification(shell, shell->job_list, FALSE);
srcs/jobcontrol/wait_job.c:	pid = waitpid(process->pid, &status, WUNTRACED);
srcs/jobcontrol/wait_job.c:	do_job_notification(shell, shell->launched_jobs, TRUE);
srcs/jobcontrol/wait_job.c:		do_job_notification(shell, shell->job_list, FALSE);
srcs/misc/abs_path.c:/*   Created: 2019/10/13 14:02:32 by mpivet-p          #+#    #+#             */
srcs/misc/abs_path.c:/*   Updated: 2020/03/08 15:41:45 by mpivet-p         ###   ########.fr       */
srcs/misc/abs_path.c:		if (shell && shell->cd.pwd_error >= TRUE)
srcs/misc/abs_path.c:	if (shell && shell->cd.pwd_error >= TRUE)
srcs/misc/abs_path_tools.c:	i = ft_strlen(path) - 1;
srcs/misc/abs_path_tools.c:		i--;
srcs/misc/abs_path_tools.c:	if (abs[j - 1] != '/')
srcs/misc/check_args.c:/*   Created: 2019/10/01 03:57:59 by mpivet-p          #+#    #+#             */
srcs/misc/errors.c:/*   Created: 2020/01/15 20:32:08 by mpivet-p          #+#    #+#             */
srcs/misc/errors.c:/*   Updated: 2020/03/08 15:42:08 by mpivet-p         ###   ########.fr       */
srcs/misc/errors.c:		ft_dprintf(STDERR_FILENO, "42sh: %s: -%c: invalid option\n", name, c);
srcs/misc/ft_access.c:/*   Created: 2019/10/15 00:18:54 by mpivet-p          #+#    #+#             */
srcs/misc/ft_access.c:/*   Updated: 2020/03/08 15:42:33 by mpivet-p         ###   ########.fr       */
srcs/misc/ft_access.c:		depth--;
srcs/misc/ft_access.c:	i = ptr - path;
srcs/misc/is_a_dir.c:/*   Created: 2019/11/02 21:25:39 by mpivet-p          #+#    #+#             */
srcs/misc/output.c:/*   Updated: 2020/03/08 15:42:44 by mpivet-p         ###   ########.fr       */
srcs/misc/output.c:		shell->build.release, shell->build.version, shell->build.patch,
srcs/misc/quit_shell.c:/*   Created: 2019/11/26 23:52:50 by mpivet-p          #+#    #+#             */
srcs/misc/quit_shell.c:/*   Updated: 2020/03/08 15:43:10 by mpivet-p         ###   ########.fr       */
srcs/misc/quit_shell.c:	if (shell->is_interactive)
srcs/misc/quit_shell.c:		save_history(&shell->term);
srcs/misc/quit_shell.c:	if (shell->is_interactive && v == TRUE)
srcs/misc/recall.c:/*   Created: 2019/10/01 01:37:25 by mpivet-p          #+#    #+#             */
srcs/signals/init_signals.c:/*   Created: 2019/11/24 18:59:53 by mpivet-p          #+#    #+#             */
srcs/signals/init_signals.c:/*   Updated: 2020/03/10 15:52:25 by mpivet-p         ###   ########.fr       */
srcs/signals/init_signals.c:	if (get_size(&(shell->term)) != SUCCESS || update_termsize(shell))
srcs/signals/sigint.c:/*   Created: 2019/11/20 16:45:16 by mpivet-p          #+#    #+#             */
srcs/signals/sigint.c:/*   Updated: 2020/03/08 15:43:42 by mpivet-p         ###   ########.fr       */
srcs/signals/sigint.c:	if (shell->term.status == CMD_PROMPT)
srcs/signals/sigint.c:		goto_prompt(&shell->term);
srcs/signals/sigint.c:		ft_strdel(&shell->term.buffer);
srcs/signals/sigint.c:		ft_strdel(&shell->term.tmp_buff);
srcs/signals/sigint.c:		shell->term.buffer = ft_memalloc(BUFF_SIZE);
srcs/signals/sigint.c:	else if (shell->term.status == CMD_SUBPROMPT)
srcs/signals/sigint.c:		if (shell->heredoc)
srcs/signals/sigint.c:			shell->heredoc = 0;
srcs/signals/sigint.c:		ft_strdel(&shell->term.buffer);
srcs/signals/sigint.c:		shell->term.buffer = ft_strdup(shell->term.tmp_buff);
srcs/signals/sigint.c:		save_history(&shell->term);
srcs/signals/sigint.c:		ft_strdel(&shell->term.buffer);
srcs/signals/sigint.c:		shell->term.buffer = ft_memalloc(BUFF_SIZE);
srcs/signals/sigint.c:		shell->term.status = CMD_PROMPT;
srcs/signals/sigint.c:		ft_strdel(&shell->term.prompt);
srcs/signals/sigint.c:		display_prompt(&(shell->term));
srcs/signals/sigint.c:		shell->job_list = NULL;
srcs/signals/sigint.c:	shell->status = 128 + signum;
