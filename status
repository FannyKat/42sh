srcs/LPA/analyzer/analyze.c:	shell->job_list = anal->job_list;
srcs/LPA/lexer_parser_analyzer.c:	lxr_tok = lexer(shell->term.buffer);
srcs/builtins/bg.c:	if (!(shell->is_interactive))
srcs/builtins/bg.c:		&& get_job(shell->launched_jobs, NULL) == NULL)
srcs/builtins/bg.c:		job = get_job(shell->launched_jobs, process->av[i]);
srcs/builtins/cd.c:	if ((var = search_db(shell->env, "HOME")) == NULL)
srcs/builtins/cd.c:	if ((var = search_db(shell->env, "OLDPWD")) == NULL)
srcs/builtins/exit.c:	if (are_jobs_done(shell, shell->launched_jobs) != TRUE)
srcs/builtins/exit.c:		return (shell->status);
srcs/builtins/exit.c:		quit_shell(shell, shell->status, 1);
srcs/builtins/export.c:		free_hash_map(&shell->hash);
srcs/builtins/export.c:	db = shell->env;
srcs/builtins/fc/fc.c:	if ((w = shell->term.history) == NULL)
srcs/builtins/fc/fc_launch_editor.c:		ft_lstappend(&(shell->launched_jobs), job_ptr);
srcs/builtins/fc/fc_specifier.c:	ft_strdel(&shell->term.buffer);
srcs/builtins/fc/fc_specifier.c:	if ((shell->term.buffer = ft_strdup(get_entry(w, cmd))) == NULL)
srcs/builtins/fg.c:	if (!(shell->is_interactive))
srcs/builtins/fg.c:	job = get_job(shell->launched_jobs, process->av[i]);
srcs/builtins/hash/add_hash_map.c:	shell->hash.lenght++;
srcs/builtins/hash/add_hash_map.c:	load_factor = (float)shell->hash.lenght / shell->hash.size;
srcs/builtins/hash/add_hash_map.c:	shell->hash.value = get_hash(key, shell->hash.size);
srcs/builtins/hash/add_hash_map.c:	if (!(ft_lstappend(&shell->hash.map[shell->hash.value],
srcs/builtins/hash/add_hash_map.c:		ft_lstnew(fetch_hash_db(&shell->db, key, value, fmt),
srcs/builtins/hash/add_hash_map.c:	hash = get_hash(process->av[i], shell->hash.size);
srcs/builtins/hash/add_hash_map.c:	map = shell->hash.map[hash];
srcs/builtins/hash/add_hash_map.c:	shell->hash.value = get_hash(process->av[i], shell->hash.size);
srcs/builtins/hash/add_hash_map.c:	sub_map = shell->hash.map[shell->hash.value];
srcs/builtins/hash/add_hash_map.c:	if (shell->hash.map == NULL
srcs/builtins/hash/add_hash_map.c:		&& !(shell->hash.map = ft_memalloc(sizeof(t_lst*) * shell->hash.size)))
srcs/builtins/hash/add_hash_map.c:		return (hash_error(&shell->hash));
srcs/builtins/hash/add_hash_map.c:			return (hash_error(&shell->hash));
srcs/builtins/hash/add_hash_map.c:				return (hash_error(&shell->hash));
srcs/builtins/hash/add_hash_map.c:	if (shell->hash.lenght == 0)
srcs/builtins/hash/add_hash_map.c:		reset_hash(&shell->hash);
srcs/builtins/hash/hash_opt.c:	free_hash_map(&shell->hash);
srcs/builtins/hash/hash_opt_tools.c:	if ((map = shell->hash.map) == NULL)
srcs/builtins/hash/hash_opt_tools.c:	while (++i < shell->hash.size)
srcs/builtins/hash/hash_opt_tools.c:	if (shell->hash.map == NULL || process == NULL)
srcs/builtins/hash/hash_opt_tools.c:	hash_value = get_hash(process, shell->hash.size);
srcs/builtins/hash/hash_opt_tools.c:	map = shell->hash.map[hash_value];
srcs/builtins/hash/hash_opt_tools.c:		shell->hash.map[hash_value] = map->next;
srcs/builtins/hash/hash_opt_tools.c:		return (free_hash_key(&shell->hash, map));
srcs/builtins/hash/hash_opt_tools.c:	free_hash_key(&shell->hash, map);
srcs/builtins/hash/hash_opt_tools.c:	if (shell->hash.map)
srcs/builtins/hash/hash_opt_tools.c:		map = shell->hash.map;
srcs/builtins/hash/hash_opt_tools.c:		shell->hash.value = get_hash(process->av[i], shell->hash.size);
srcs/builtins/hash/hash_opt_tools.c:		if (map == NULL || map[shell->hash.value] == NULL)
srcs/builtins/hash/hash_opt_tools.c:		find_hash_sub_map(process, map[shell->hash.value], i, ac);
srcs/builtins/hash/locate_hash.c:	shell->hash.value = get_hash(process->av[0], shell->hash.size);
srcs/builtins/hash/locate_hash.c:	if (shell->hash.map == NULL || shell->hash.map[shell->hash.value] == NULL)
srcs/builtins/hash/locate_hash.c:	sub_map = shell->hash.map[shell->hash.value];
srcs/builtins/hash/resize_hash_map.c:	while (i < shell->hash.size)
srcs/builtins/hash/resize_hash_map.c:			shell->hash.value = get_hash(((t_db*)(sub_map->content))->key,
srcs/builtins/hash/resize_hash_map.c:									(shell->hash.size * 2));
srcs/builtins/hash/resize_hash_map.c:			if (!(ft_lstappend(&new_map[shell->hash.value],
srcs/builtins/hash/resize_hash_map.c:					ft_lstnew(fetch_hash_db(&shell->db,
srcs/builtins/hash/resize_hash_map.c:	map = shell->hash.map;
srcs/builtins/hash/resize_hash_map.c:	tmp_hash_lenght = shell->hash.lenght;
srcs/builtins/hash/resize_hash_map.c:	tmp_hash_size = shell->hash.size;
srcs/builtins/hash/resize_hash_map.c:	if (!(new_map = ft_memalloc(sizeof(t_lst*) * (shell->hash.size * 2))))
srcs/builtins/hash/resize_hash_map.c:	free_hash_map(&(shell->hash));
srcs/builtins/hash/resize_hash_map.c:	shell->hash.map = new_map;
srcs/builtins/hash/resize_hash_map.c:	shell->hash.size = tmp_hash_size * 2;
srcs/builtins/hash/resize_hash_map.c:	shell->hash.lenght = tmp_hash_lenght;
srcs/builtins/jobs.c:	job_list = shell->launched_jobs;
srcs/builtins/jobs.c:	if (shell->launched_jobs)
srcs/builtins/jobs.c:		job = get_job(shell->launched_jobs, process->av[i]);
srcs/builtins/set.c:	ptr = shell->env;
srcs/builtins/set.c:	shell->db.key = ft_itoa(count);
srcs/builtins/set.c:	shell->db.value = ft_strdup(arg);
srcs/builtins/set.c:	shell->db.type = SPECIAL_VAR;
srcs/builtins/set.c:	if (!shell->db.key || !shell->db.value || ft_lstappend(&shell->pos_vars
srcs/builtins/set.c:				, ft_lstnew(&shell->db, sizeof(t_db))) == NULL)
srcs/builtins/set.c:		ft_strdel(&(shell->db.key));
srcs/builtins/set.c:		ft_strdel(&(shell->db.value));
srcs/builtins/set.c:	free_db(shell->pos_vars);
srcs/builtins/set.c:	shell->pos_vars = NULL;
srcs/builtins/unset.c:		free_hash_map(&shell->hash);
srcs/cmdline/auto_c/ac_tools.c:	env = term->shell->env;
srcs/cmdline/auto_c/ac_tools.c:	env = shell->env;
srcs/cmdline/prompt/check_subprompt.c:	if (quotes_is_matching(&shell->term, &quote) == TRUE)
srcs/cmdline/prompt/check_subprompt.c:		if (check_backslash(&shell->term, &quote) == FALSE)
srcs/cmdline/prompt/check_subprompt.c:		shell->term.sub_prompt = TRUE;
srcs/cmdline/prompt/check_subprompt.c:		ft_strdel(&shell->term.prompt);
srcs/cmdline/prompt/check_subprompt.c:		load_subprompt(quote, &shell->term);
srcs/cmdline/prompt/heredoc.c:	if (read_multiline(&shell->term, NULL) == FALSE)
srcs/cmdline/prompt/heredoc.c:		if (shell->term.flag == TRUE)
srcs/cmdline/prompt/heredoc.c:		if (ft_strcmp(shell->term.buffer, key))
srcs/cmdline/prompt/heredoc.c:			shell->term.buffer = ft_strjoinf(shell->term.tmp_buff,
srcs/cmdline/prompt/heredoc.c:														shell->term.buffer, 2);
srcs/cmdline/prompt/heredoc.c:			shell->term.buffer = ft_strjoinf(shell->term.buffer, NEW_LINE, 1);
srcs/cmdline/prompt/heredoc.c:			ft_strdel(&shell->term.tmp_buff);
srcs/cmdline/prompt/heredoc.c:			shell->term.tmp_buff = ft_strdup(shell->term.buffer);
srcs/cmdline/prompt/heredoc.c:	buffer = ft_strdup(shell->term.tmp_buff);
srcs/cmdline/prompt/heredoc.c:	ft_strdel(&shell->term.tmp_buff);
srcs/cmdline/prompt/heredoc.c:	shell->term.status = CMD_DONE;
srcs/cmdline/prompt/heredoc.c:	ft_strdel(&shell->term.buffer);
srcs/cmdline/prompt/heredoc.c:	shell->term.buffer = ft_strsub(buffer, 0, i);
srcs/cmdline/prompt/heredoc.c:	shell->term.buffer = ft_strjoinf(shell->term.buffer, NEW_LINE, 1);
srcs/cmdline/prompt/heredoc.c:	shell->term.tmp_buff = ft_strdup(shell->term.buffer);
srcs/cmdline/prompt/heredoc.c:	shell->term.status = CMD_SUBPROMPT;
srcs/cmdline/prompt/heredoc.c:	while (TRUE && shell->term.status == CMD_SUBPROMPT)
srcs/cmdline/prompt/heredoc.c:		ft_strdel(&shell->term.buffer);
srcs/cmdline/prompt/heredoc.c:		shell->term.buffer = ft_memalloc(BUFF_SIZE);
srcs/cmdline/prompt/heredoc.c:		display_subprompt(&shell->term);
srcs/cmdline/prompt/heredoc.c:		else if (*shell->term.prompt
srcs/cmdline/prompt/heredoc.c:			|| (!*shell->term.prompt && shell->term.buffer))
srcs/cmdline/prompt/heredoc.c:		if (shell->term.status == CMD_PROMPT)
srcs/cmdline/prompt/heredoc.c:	shell->term.status = CMD_DONE;
srcs/cmdline/prompt/prompt.c:	if (!*(shell->term).buffer && get_mask(buff) == CTRL_D)
srcs/cmdline/prompt/prompt.c:		if (are_jobs_done(shell, shell->launched_jobs) != TRUE)
srcs/cmdline/prompt/prompt.c:		write_history(&shell->term);
srcs/cmdline/prompt/prompt.c:	if ((db = search_db(shell->env, key)) == NULL)
srcs/cmdline/prompt/prompt.c:		shell->term.prompt = ft_strnew(0);
srcs/cmdline/prompt/prompt.c:		shell->term.prompt = ft_strsub(db->value, 1, 10);
srcs/cmdline/prompt/prompt.c:		shell->term.prompt = ft_strsub(db->value, 1, 2);
srcs/cmdline/prompt/prompt.c:		shell->term.prompt = ft_strdup(db->value);
srcs/cmdline/prompt/prompt.c:	shell->term.status = CMD_PROMPT;
srcs/cmdline/prompt/prompt.c:	shell->term.buffer = ft_memalloc(BUFF_SIZE);
srcs/cmdline/prompt/prompt.c:	if (init_termcaps(&shell->term) == FAILURE)
srcs/cmdline/prompt/prompt.c:	display_prompt(&shell->term);
srcs/cmdline/prompt/prompt.c:		if (check_caps(buff, &shell->term) == TRUE)
srcs/cmdline/prompt/prompt.c:		else if (*shell->term.prompt
srcs/cmdline/prompt/prompt.c:			|| (!*shell->term.prompt && shell->term.buffer))
srcs/cmdline/prompt/prompt.c:	shell->term.status = CMD_DONE;
srcs/cmdline/prompt/prompt.c:		check_expansions(&shell->term);
srcs/cmdline/term_config.c:	if (tcgetattr(STDIN_FILENO, &(shell->old_t)) == FAILURE)
srcs/cmdline/term_config.c:	shell->new_t = shell->old_t;
srcs/cmdline/term_config.c:	shell->new_t.c_lflag &= ~(ICANON | ECHO);
srcs/cmdline/term_config.c:	shell->new_t.c_cc[VMIN] = 1;
srcs/cmdline/term_config.c:	shell->new_t.c_cc[VTIME] = 0;
srcs/cmdline/term_config.c:	if (tcsetattr(STDIN_FILENO, TCSADRAIN, &(shell->new_t)) == FAILURE)
srcs/cmdline/term_config.c:	if (tcsetattr(STDIN_FILENO, TCSADRAIN, &(shell->new_t)) == FAILURE)
srcs/cmdline/term_config.c:	if (tcsetattr(STDIN_FILENO, TCSANOW, &(shell->old_t)) == FAILURE)
srcs/cmdline/term_config.c:	ft_strdel(&shell->term.tmp_buff);
srcs/cmdline/term_config.c:	ft_strdel(&shell->term.prompt);
srcs/cmdline/term_config.c:	shell->term.cmd = NULL;
srcs/core/free_handler.c:	ft_strdel(&shell->term.buffer);
srcs/core/free_handler.c:	ft_freejoblist(&shell->job_list);
srcs/core/free_handler.c:	free_db(shell->env);
srcs/core/free_handler.c:	free_history(&shell->term);
srcs/core/free_handler.c:	free_hash_map(&shell->hash);
srcs/core/init_shell.c:	while (tcgetpgrp(shell->terminal) != (shell->pgid = getpgrp()))
srcs/core/init_shell.c:		kill(-shell->pgid, SIGTTIN);
srcs/core/init_shell.c:	shell->pgid = getpid();
srcs/core/init_shell.c:	if (setpgid(shell->pgid, shell->pgid) < 0)
srcs/core/init_shell.c:	if (tcsetpgrp(shell->terminal, shell->pgid) != SUCCESS)
srcs/core/init_shell.c:	shell->build = (struct s_build){DATE, BUILDP + 1, BUILDR, BUILDV};
srcs/core/init_shell.c:	shell->hash.size = HASH_SIZE;
srcs/core/init_shell.c:	shell->terminal = STDIN_FILENO;
srcs/core/init_shell.c:	if (isatty(shell->terminal) == TRUE)
srcs/core/init_shell.c:		shell->is_interactive = TRUE;
srcs/core/init_shell.c:		shell->is_interactive = FALSE;
srcs/core/shell_loader.c:	while (get_next_line(STDIN_FILENO, &shell->term.buffer))
srcs/core/shell_loader.c:		while (shell->term.buffer[i])
srcs/core/shell_loader.c:			if (!ft_is_print(shell->term.buffer[i]))
srcs/core/shell_loader.c:	quit_shell(shell, shell->status, FALSE);
srcs/core/shell_loader.c:	init_cmd_line(shell, &shell->term);
srcs/core/shell_loader.c:		do_job_notification(shell, shell->launched_jobs);
srcs/core/shell_loader.c:		save_history(&shell->term);
srcs/db/db_tools.c:	db = search_db(shell->env, key);
srcs/db/db_tools.c:		ft_lstappend(&(shell->env),
srcs/db/db_tools.c:			ft_lstnew(fetch_db(&(shell->db), key, var_type), sizeof(t_db)));
srcs/db/db_tools.c:		db = search_db(shell->env, key);
srcs/db/db_tools.c:	prev = shell->env;
srcs/db/db_tools.c:	env = shell->env;
srcs/db/db_tools.c:			shell->env = env->next;
srcs/db/get_opt.c:		shell->build.release, shell->build.version, shell->build.patch);
srcs/db/get_opt.c:		shell->build.release, shell->build.version, shell->build.patch);
srcs/db/get_opt.c:	shell->is_interactive = FALSE;
srcs/db/get_opt.c:	shell->term.buffer = ft_strdup(av[2]);
srcs/db/process_vars.c:	job = get_job(shell->launched_jobs, "%%");
srcs/db/set_env.c:	fetch_db(&shell->db, "OLDPWD", EXPORT_VAR);
srcs/db/set_env.c:	ft_strdel(&(shell->db.value));
srcs/db/set_env.c:	ft_lstappend(&shell->env, ft_lstnew(&(shell->db), sizeof(t_db)));
srcs/db/set_env.c:			ft_lstappend(&shell->env, ft_lstnew(fetch_db(&shell->db
srcs/db/set_updates.c:	if (search_db(shell->env, "TERM") == NULL)
srcs/db/set_updates.c:		if (ft_lstappend(&(shell->env), ft_lstnew(
srcs/db/set_updates.c:				fetch_db(&(shell->db), "TERM=dumb", INTERNAL_VAR)
srcs/db/set_updates.c:		if (!(value = ft_itoa(shell->term.ws_li))
srcs/db/set_updates.c:		if (!(value = ft_itoa(shell->term.ws_col))
srcs/db/special_vars.c:		value = ft_itoa(ft_lstlen(shell->pos_vars));
srcs/db/special_vars.c:		value = ft_itoa(shell->status);
srcs/db/version.c:	ft_itoabuf(shell->build.release, version);
srcs/db/version.c:	ft_itoabuf(shell->build.version, version);
srcs/db/version.c:	ft_itoabuf(shell->build.patch, version);
srcs/exec/exec_process.c:		if (tcsetpgrp(shell->terminal, process->pgid) != SUCCESS)
srcs/exec/exec_process.c:		wait_for_process(shell, shell->job_list, process);
srcs/exec/exec_process.c:		if (tcsetpgrp(shell->terminal, shell->pgid) != SUCCESS)
srcs/exec/exec_process.c:		shell->is_interactive = TRUE;
srcs/exec/exec_process.c:	if (shell->is_interactive == TRUE)
srcs/exec/exec_process.c:		wait_for_process(shell, shell->job_list, process);
srcs/exec/get_bin.c:	if ((db = search_db(shell->env, "PATH")) == NULL)
srcs/exec/redirections/exec_redirs.c:			((t_redir*)redirs->content)->dup_fd[0] = shell->heredoc++;
srcs/exec/set_envp.c:	env = shell->env;
srcs/exec/set_envp.c:	env = shell->env;
srcs/exec/status_handler.c:		shell->status = status + 128;
srcs/exec/status_handler.c:		shell->status = WEXITSTATUS(status);
srcs/exec/task_master.c:	ptr = shell->job_list;
srcs/exec/task_master.c:	if (shell->job_list != job)
srcs/exec/task_master.c:		shell->job_list = job->next;
srcs/exec/task_master.c:	if (shell->is_interactive && job_is_completed(job))
srcs/exec/task_master.c:	if (!(shell->is_interactive))
srcs/exec/task_master.c:		wait_for_job(shell, shell->job_list, job);
srcs/exec/task_master.c:		put_job_in_foreground(shell, shell->job_list, job, FALSE);
srcs/exec/task_master.c:		job->jobc_id = update_jobs(shell->launched_jobs);
srcs/exec/task_master.c:		shell->pgid = getpid();
srcs/exec/task_master.c:		job->pgid = shell->pgid;
srcs/exec/task_master.c:		shell->is_interactive = FALSE;
srcs/exec/task_master.c:		if (setpgid(shell->pgid, shell->pgid) < 0)
srcs/exec/task_master.c:		shell->status = 0;
srcs/exec/task_master.c:	job = shell->job_list;
srcs/exec/task_master.c:			ft_lstappend(&(shell->launched_jobs), job);
srcs/exec/task_master.c:	shell->job_list = NULL;
srcs/exp/assign_redir_tok_exp.c:	if (!key || !shell->env)
srcs/exp/expansion.c:		shell->status = 0;
srcs/exp/param_exp/param_exp.c:	db = search_db(shell->env, key);
srcs/exp/param_exp/param_exp.c:	if ((db_tmp = search_db(shell->env, &str[1])))
srcs/exp/param_exp/param_expansion.c:	if ((db_tmp = search_db(shell->env, str)))
srcs/exp/tilde_cmds_math_exp.c:	if ((db_tmp = search_db(shell->env, path[i])))
srcs/jobcontrol/are_jobs_done.c:	if (shell->notified != TRUE)
srcs/jobcontrol/are_jobs_done.c:		shell->notified = TRUE;
srcs/jobcontrol/continue.c:		put_job_in_foreground(shell, shell->launched_jobs, job, TRUE);
srcs/jobcontrol/foreground.c:	if (tcsetpgrp(shell->terminal, job->pgid) != SUCCESS)
srcs/jobcontrol/foreground.c:	if (tcsetpgrp(shell->terminal, shell->pgid) != SUCCESS)
srcs/jobcontrol/jobc_id.c:	jobs = shell->launched_jobs;
srcs/jobcontrol/launch_process.c:		shell->status = process->status;
srcs/jobcontrol/launch_process.c:	if (shell->is_interactive)
srcs/jobcontrol/mark_process_status.c:			shell->status = 128 + 18;
srcs/jobcontrol/notifications.c:	if (!shell->launched_jobs)
srcs/jobcontrol/notifications.c:		&& !mark_process_status(shell, shell->launched_jobs, pid, status))
srcs/jobcontrol/notifications.c:	ptr = shell->launched_jobs;
srcs/jobcontrol/notifications.c:	if (shell->launched_jobs != job)
srcs/jobcontrol/notifications.c:		shell->launched_jobs = job->next;
srcs/jobcontrol/notifications.c:			job = shell->launched_jobs;
srcs/misc/output.c:		shell->build.release, shell->build.version, shell->build.patch,
srcs/misc/quit_shell.c:	if (shell->is_interactive)
srcs/misc/quit_shell.c:	if (shell->is_interactive && v == TRUE)
srcs/signals/init_signals.c:	if (get_size(&(shell->term)) != SUCCESS || update_termsize(shell))
srcs/signals/sigint.c:	if (shell->term.status == CMD_PROMPT)
srcs/signals/sigint.c:		while (shell->term.x_index < shell->term.width)
srcs/signals/sigint.c:			move_right(shell->term.buffer, &(shell->term));
srcs/signals/sigint.c:		ft_strdel(&shell->term.buffer);
srcs/signals/sigint.c:		shell->term.buffer = ft_memalloc(BUFF_SIZE);
srcs/signals/sigint.c:		display_prompt(&(shell->term));
srcs/signals/sigint.c:	else if (shell->term.status == CMD_SUBPROMPT)
srcs/signals/sigint.c:		ft_strdel(&shell->term.buffer);
srcs/signals/sigint.c:		shell->term.buffer = ft_strdup(shell->term.tmp_buff);
srcs/signals/sigint.c:		save_history(&shell->term);
srcs/signals/sigint.c:		ft_strdel(&shell->term.buffer);
srcs/signals/sigint.c:		shell->term.buffer = ft_memalloc(BUFF_SIZE);
srcs/signals/sigint.c:		shell->term.status = CMD_PROMPT;
srcs/signals/sigint.c:		ft_strdel(&shell->term.prompt);
srcs/signals/sigint.c:		display_prompt(&(shell->term));
srcs/signals/sigint.c:	shell->status = 128 + signum;
